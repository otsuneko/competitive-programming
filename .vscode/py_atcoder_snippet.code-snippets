{
    "Template_AtCoder": {
        "prefix": "Template_AtCoder",
        "body": [
            "import sys",
            "input = lambda: sys.stdin.readline().rstrip()",
            "INF = 10**18",
            "",
            "",
        ],
        "description": "AtCoder template"
    },
    "Template_Codeforces": {
        "prefix": "Template_Codeforces",
        "body": [
            "import sys",
            "input = lambda: sys.stdin.readline().rstrip()",
            "sys.setrecursionlimit(10**5)",
            "INF = 10**18",
            "",
            "def solve():",
            "    N = int(input())",
            "    ",
            "",
            "Q = int(input())",
            "for _ in range(Q):",
            "    solve()",
        ],
        "description": "Codeforces template"
    },
    "FileInput": {
        "prefix": "FileInput",
        "body": [
            "import sys",
            "stdin = open('tmp\\abcxxx_a\\sample-1.in')",
        ],
        "description": "FileInput"
    },
	"input_line int(single)":{
		"prefix":"input_line int(single)",
		"body":["int(input())"],
		"description":"input int(single)",
	},
	"input_line int(multiple)":{
		"prefix":"input_line int(multiple)",
		"body":["map(int,input().split())"],
		"description":"input int(multiple)",
	},
	"input_line list(int)":{
		"prefix":"input_line list(int)",
		"body":["list(map(int,input().split()))"],
		"description":"input list(int)",
	},
    "input_lines list(int)":{
		"prefix":"input_lines list(int)",
		"body":["[int(input()) for _ in range($1)]"],
		"description":"input_lines list(int)",
	},
	"input_lines list(multiple_int)":{
		"prefix":"input_lines list(multiple_int)",
		"body":["[list(map(int,input().split())) for _ in range($1)]"],
		"description":"input_lines list(multiple_int)",
	},
	"input_line list(string)":{
		"prefix":"input_line list(string)",
		"body":["list(input())"],
		"description":"input line list(string)",
	},
    "input_lines list(string)":{
		"prefix":"input_lines list(string)",
		"body":["[list(input()) for _ in range($1)]"],
		"description":"input_lines list(string)",
	},
    "print":{
		"prefix":"print",
		"body":["print($1)"],
		"description":"print",
	},
    "print_sep":{
		"prefix":"print_sep",
		"body":["print(*$1, sep=\"\\n\")"],
		"description":"print_sep",
	},
    "print_YesNo": {
        "prefix": "print_YesNo",
        "body": [
            "print([\"No\",\"Yes\"][$1])",
        ],
        "description": "print_YesNo"
    },
    "print_YESNO": {
        "prefix": "print_YESNO",
        "body": [
            "print([\"NO\",\"YES\"][$1])",
        ],
        "description": "print_YESNO"
    },
    "deque": {
        "prefix": "deque",
        "body": [
            "from collections import deque",
            "d = deque($1)",
        ],
        "description": "deque"
    },
    "heapq": {
        "prefix": "heapq",
        "body": [
            "import heapq  # heapqライブラリのimport",
            "'''",
            "a = [1, 6, 8, 0, -1]",
            "heapq.heapify(a)  # リストを優先度付きキューへ(リストが空の場合はheapify()不要)",
            "heapq.heappop(a)  # 最小値の取り出し",
            "heapq.heappush(a, -2)  # 要素の挿入",
            "'''",
        ],
        "description": "heapq(priority queue)"
    },
    "sort_with_index": {
        "prefix": "sort_with_index",
        "body": [
            "def sort_with_index(arr, reverse=False):",
            "    if reverse:",
            "        return sorted([ (x,i) for i, x in enumerate(arr)], reverse=True)",
            "    else:",
            "        return sorted([ (x,i) for i, x in enumerate(arr)])",
        ],
        "description": "index付きソート"
    },
    "sort_multiple": {
        "prefix": "sort_multiple",
        "body": [
            "# 昇順降順を入れ替える場合はlambda式の正負を反転",
            "$1.sort(key=lambda x:(-x[1],x[0]))",
        ],
        "description": "多次元リストのソート"
    },
    "inverse": {
        "prefix": "inverse",
        "body": [
            "inv = list(zip(*$1))",
        ],
        "description": "二次元配列の転置"
    },
    "baisuu": {
        "prefix": "baisuu",
        "body": [
            "2の倍数：1の位が2,4,6,8,0",
            "3の倍数：各桁の数字の和が3の倍数",
            "4の倍数：下2桁が4の倍数",
            "5の倍数：1の位が5,0",
            "6の倍数：2の倍数かつ3の倍数",
            "7の倍数：3桁ごとに区切った数字を1つ飛ばしに足した和の差が7の倍数",
            "8の倍数：下3桁が8の倍数",
            "9の倍数：各桁の数字の和が9の倍数",
            "11の倍数：(奇数桁目の数字の和)-(偶数桁目の数字の和)が11の倍数か0",
            "13の倍数：3桁ごとに区切った数字を1つ飛ばしに足した和の差が13の倍数",
        ],
        "description": "倍数判別法"
    },
    "round_up": {
        "prefix": "round_up",
        "body": [
            "C = -(-A // B)",
        ],
        "description": "除算の切り上げ"
    },
    "mod_1000000007": {
        "prefix": "mod_1000000007",
        "body": [
            "mod = 10**9+7",
        ],
        "description": "数え上げでよく使う数値その1"
    },
    "mod_998244353": {
        "prefix": "mod_998244353",
        "body": [
            "mod = 998244353",
        ],
        "description": "数え上げでよく使う数値その2"
    },
    "round_half_up": {
        "prefix": "round_half_up",
        "body": [
            "from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN",
            "f = 123.456",
            "print(Decimal(str(f)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))",
            "#123",
            "print(Decimal(str(f)).quantize(Decimal('0.1'), rounding=ROUND_HALF_UP))",
            "#123.5",
            "print(Decimal(str(f)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
            "#123.46",
        ],
        "description": "四捨五入"
    },
    "gcd": {
        "prefix": "gcd",
        "body": [
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    else:",
            "        return gcd(b,a%b)",
        ],
        "description": "a,bの最大公約数"
    },
    "gcdlist": {
        "prefix": "gcdlist",
        "body": [
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    else:",
            "        return gcd(b,a%b)",
            "",
            "def gcdlist(l):",
            "    a = l[0]",
            "    for i in range(len(l)):",
            "        a = gcd(a,l[i])",
            "    return a",
        ],
        "description": "リスト l の最大公約数"
    },
    "lcm": {
        "prefix": "lcm",
        "body": [
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    else:",
            "        return gcd(b,a%b)",
            "",
            "def lcm(a, b):",
            "    return a * b // gcd (a, b)",
        ],
        "description": "a,bの最小公倍数"
    },
    "lcmlist": {
        "prefix": "lcmlist",
        "body": [
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    else:",
            "        return gcd(b,a%b)",
            "",
            "def lcmlist(l):",
            "    a = l[0]",
            "    for i in range(1, len(l)):",
            "        a = (a * l[i]) // gcd(a, l[i])",
            "    return a",
        ],
        "description": "リスト l の最小公倍数"
    },
    "digsum": {
        "prefix": "digsum",
        "body": [
            "def digsum(n):",
            "    res = 0",
            "    while n > 0:",
            "        res += n%10",
            "        n //= 10",
            "    ",
            "    return res",
        ],
        "description": "桁和"
    },
    "base_n": {
        "prefix": "base_n",
        "body": [
            "# 10進数を2,8,16進数に変換する",
            "x = 10",
            "bin_x = bin(x)[2:]",
            "oct_x = oct(x)[2:]",
            "hex_x = hex(x)[2:]",
            "",
            "#10進数→n進数",
            "def base10int(value, base):",
            "    if value >= base:",
            "        return base10int(value//base, base) + str(value % base)",
            "    return str(value % base)",
            "",
            "print(base10int(100, 2))",
            "# 1210",
            "",
            "#10進数→n進数(返り値リスト)",
            "def base10int(value, base):",
            "    upper = value >= base and base10int(value // base, base) or []",
            "    return upper + [value % base]  # リストの結合",
            "",
            "print(base10int(100, 4))",
            "# [1, 2, 1, 0]",
            "",
            "# 2,8,16進数を10進数に変換する",
            "print(int(bin_x, 2))",
            "print(int(oct_x, 8))",
            "print(int(hex_x, 16))",
            "",
            "#n進数→10進数(前処理として、各桁の値を格納したリストが必要)",
            "def decode(digits, base):",
            "    value = 0",
            "    for digit in digits:",
            "        value = value * base + digit",
            "    return value",
        ],
        "description": "進数変換"
    },
    "divisor": {
        "prefix": "divisor",
        "body": [
            "def divisor(n):",
            "    lower_divisors , upper_divisors = [], []",
            "    i = 1",
            "    while i*i <= n:",
            "        if n % i == 0:",
            "            lower_divisors.append(i)",
            "            if i != n // i:",
            "                upper_divisors.append(n//i)",
            "        i += 1",
            "    return lower_divisors + upper_divisors[::-1]",
        ],
        "description": "nの約数を全て求める(O(√N))"
    },
    "mcb": {
        "prefix": "mcb",
        "body": [
            "def mcb(N):",
            "    L,R = 1, 10**5+1 # Nの桁数によってRの桁数も変化(例：N=10^15　⇒　R=10^5+1)",
            "    while R-L > 1:",
            "        mid=(L+R)/2",
            "        if mid*mid*mid <= N:",
            "            L=mid",
            "        else:",
            "            R=mid",
            "    return L",
        ],
        "description": "三乗根"
    },
    "prime_decomposition": {
        "prefix": "prime_decomposition",
        "body": [
            "def prime_decomposition(n):",
            "  i = 2",
            "  table = []",
            "  while i * i <= n:",
            "    while n % i == 0:",
            "      n = n//i",
            "      table.append(i)",
            "    i += 1",
            "  if n > 1:",
            "    table.append(n)",
            "  return table",
        ],
        "description": "nを素因数分解したリストを返す"
    },
    "is_prime": {
        "prefix": "is_prime",
        "body": [
            "def is_prime(n):",
            "    for i in range(2, n + 1):",
            "        if i * i > n:",
            "            break",
            "        if n % i == 0:",
            "            return False",
            "    return n != 1",
        ],
        "description": "素数判定"
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "def sieve(n):",
            "    is_prime = [True for _ in range(n+1)]",
            "    is_prime[0] = False",
            "    is_prime[1] = False",
            "",
            "    for i in range(2, n+1):",
            "        if not is_prime[i]:",
            "            continue",
            "        for j in range(i*2, n+1, i):",
            "            is_prime[j] = False",
            "    table = [ i-1 for i in range(1, n+1) if is_prime[i-1]] # 素数のリスト",
            "    return table",
        ],
        "description": "エラトステネスの篩"
    },
    "pow_doubling": {
        "prefix": "pow_doubling",
        "body": [
            "def pos(x, n, m):",
            "    if n == 0:",
            "        return 1",
            "    res = pos(x*x%m, n//2, m)",
            "    if n%2 == 1:",
            "        res = res*x%m",
            "    return res",
        ],
        "description": "高速べき乗計算"
    },
    "euler_phi": {
        "prefix": "euler_phi",
        "body": [
            "def euler_phi(n):",
            "    res = n",
            "    x = 2",
            "    while x*x <= n:",
            "        if n % x == 0:",
            "            res = res // x * (x-1)",
            "            while n % x == 0:",
            "                n //= x",
            "        x += 1",
            "    if n > 1:",
            "        res = res // n * (n-1)",
            "    return res",
            "",
            "# calculate φ(x) for 1 <= x <= M",
            "M = 10**6",
            "*phi, = range(M+1)",
            "for x in range(2, M+1):",
            "    if phi[x] == x:",
            "        for y in range(x, M+1, x):",
            "            phi[y] = phi[y] // x * (x-1)",
        ],
        "description": "オイラーのファイ関数"
    },
    "Modint": {
        "prefix": "Modint",
        "body": [
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % MOD",
            "",
            "    def __str__(self):",
            "        return str(self.x)",
            "",
            "    __repr__ = __str__",
            "",
            "    def __add__(self, other):",
            "        return (",
            "            ModInt(self.x + other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x + other)",
            "        )",
            "",
            "    def __sub__(self, other):",
            "        return (",
            "            ModInt(self.x - other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x - other)",
            "        )",
            "",
            "    def __mul__(self, other):",
            "        return (",
            "            ModInt(self.x * other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x * other)",
            "        )",
            "",
            "    def __truediv__(self, other):",
            "        return (",
            "            ModInt(",
            "                self.x * pow(other.x, MOD - 2, MOD)",
            "            ) if isinstance(other, ModInt) else",
            "            ModInt(self.x * pow(other, MOD - 2, MOD))",
            "        )",
            "",
            "    def __pow__(self, other):",
            "        return (",
            "            ModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt) else",
            "            ModInt(pow(self.x, other, MOD))",
            "        )",
            "",
            "    __radd__ = __add__",
            "",
            "    def __rsub__(self, other):",
            "        return (",
            "            ModInt(other.x - self.x) if isinstance(other, ModInt) else",
            "            ModInt(other - self.x)",
            "        )",
            "",
            "    __rmul__ = __mul__",
            "",
            "    def __rtruediv__(self, other):",
            "        return (",
            "            ModInt(",
            "                other.x * pow(self.x, MOD - 2, MOD)",
            "            ) if isinstance(other, ModInt) else",
            "            ModInt(other * pow(self.x, MOD - 2, MOD))",
            "        )",
            "",
            "    def __rpow__(self, other):",
            "        return (",
            "            ModInt(pow(other.x, self.x, MOD)) if isinstance(other, ModInt) else",
            "            ModInt(pow(other, self.x, MOD))",
            "        )",
            "",
            "#除算",
            "A, B = map(ModInt, (map(int, input().split())))",
            "print(A / B)",
            "",
            "#通常のintとの演算",
            "A = ModInt(int(input()))",
            "print((1 + A)**3)",
            "",
            "#SUM関数",
            "N = int(input())",
            "print(sum(ModInt(i)**2 for i in range(1, N + 1)))",
        ],
        "description": "Modint"
    },
    "bitlist": {
        "prefix": "bitlist",
        "body": [
            "import itertools",
            "num = 3 #生成するビット数",
            "bit_list = list(itertools.product([0, 1], repeat=num))",
        ],
        "description": ""
    },
    "permutationCoeff(nPr)": {
        "prefix": "permutationCoeff(nPr)",
        "body": [
            "def permutationCoeff(n, k):",
            "    fact = [0 for _ in range(n + 1)]",
            " ",
            "    # base case",
            "    fact[0] = 1",
            " ",
            "    # Calculate value",
            "    # factorials up to n",
            "    for i in range(1, n + 1):",
            "        fact[i] = i * fact[i - 1]",
            " ",
            "    # P(n, k) = n!/(n-k)!",
            "    return fact[n] // fact[n - k]",
            " ",
        ],
        "description": "順列(階乗)"
    },
    "permutation": {
        "prefix": "permutation",
        "body": [
            "import itertools",
            "",
            "seq = ('a', 'b', 'c', 'd', 'e')",
            "ptr = list(itertools.permutations(seq, 3)) #順列列挙 5P3",
        ],
        "description": "順列"
    },
    "permutation_product": {
        "prefix": "permutation_product",
        "body": [
            "import itertools",
            "seq = ('a', 'b', 'c')",
            "all = itertools.product(seq, repeat=2)",
        ],
        "description": "順列(重複あり)"
    },
    "combination": {
        "prefix": "combination",
        "body": [
            "import itertools",
            "",
            "seq = ('a', 'b', 'c', 'd', 'e')",
            "cmb = list(itertools.combinations(seq,3)) # 組み合わせ列挙 5C3",
        ],
        "description": "nCa (組み合わせ)"
    },	
    "combinations_with_replacement": {
        "prefix": "combinations_with_replacement",
        "body": [
            "import itertools",
            "seq = ('a', 'b', 'c')",
            "all = itertools.combinations_with_replacement(seq, 3)",
            "for x in all:",
            "    print(x)",
        ],
        "description": "組み合わせ(重複あり)"
    },
    "binomialCoeff(nCr)": {
        "prefix": "binomialCoeff(nCr)",
        "body": [
            "def nCr(n, r):",
            "",
            "    res = 1",
            "    for i in range(r):",
            "        res = (res*(n-i))//(i+1)",
            "",
            "    return res",
            "",
        ],
        "description": "二項係数(binomial Coefficient)、組み合わせ(nCr)"
    },
    "combination_with_repetition(nHr)": {
        "prefix": "combination_with_repetition(nHr)",
        "body": [
            "def nHr(n, r):",
            "",
            "    n = n+r-1",
            "    res = 1",
            "    for i in range(r):",
            "        res = (res*(n-i))//(i+1)",
            "",
            "    return res",
            "",
        ],
        "description": "二項係数(binomial Coefficient)、組み合わせ(nCr)"
    },
    "binomialCoeff(nCr_mod)": {
        "prefix": "binomialCoeff(nCr_mod)",
        "body": [
            "mod = 10**9 + 7",
            "# xの逆元を求める。フェルマーの小定理より、 x の逆元は x ^ (mod - 2) に等しい。計算時間はO(log(mod))程度。",
            "def modinv(x):",
            "    return pow(x,mod-2,mod)",
            "",
            "# nCrをmodで割った余りを計算",
            "def nCr(n, r):",
            "    numera = 1  # 分子",
            "    denomi = 1  # 分母",
            "",
            "    for i in range(r):",
            "        numera *= n-i",
            "        numera %= mod",
            "        denomi *= i+1",
            "        denomi %= mod",
            "    return numera * modinv(denomi) % mod",
        ],
        "description": "combination mod"
    },
    "crt": {
        "prefix": "crt",
        "body": [
            "def inv_gcd(a,b):",
            "    a=a%b",
            "    if a==0:",
            "        return (b,0)",
            "    s=b;t=a",
            "    m0=0;m1=1",
            "    while(t):",
            "        u=s//t",
            "        s-=t*u",
            "        m0-=m1*u",
            "        s,t=t,s",
            "        m0,m1=m1,m0",
            "    if m0<0:",
            "        m0+=b//s",
            "    return (s,m0)",
            "",
            "def inv_mod(x,m):",
            "    assert 1<=m",
            "    z=inv_gcd(x,m)",
            "    assert z[0]==1",
            "    return z[1]",
            "",
            "def crt(r,m):",
            "    assert len(r)==len(m)",
            "    n=len(r)",
            "    r0=0;m0=1",
            "    for i in range(n):",
            "        assert 1<=m[i]",
            "        r1=r[i]%m[i]",
            "        m1=m[i]",
            "        if m0<m1:",
            "            r0,r1=r1,r0",
            "            m0,m1=m1,m0",
            "        if (m0%m1==0):",
            "            if (r0%m1!=r1):",
            "                return (0,0)",
            "            continue",
            "        g,im=inv_gcd(m0,m1)",
            "        u1=m1//g",
            "        if ((r1-r0)%g):",
            "            return (0,0)",
            "        x=(r1-r0)//g % u1*im%u1",
            "        r0+=x*m0",
            "        m0*=u1",
            "        if r0<0:",
            "            r0+=m0",
            "    return (r0,m0)",
            " ",
            "T=int(input())",
            "for _ in range(T):",
            "    X,Y,P,Q = map(int, input().split())",
            "    ans = 10**30",
            "    for y in range(Y):",
            "        for q in range(Q):",
            "            C = [2*(X+Y),P+Q]#これで割ったら",
            "            R = [X+y,P+q]#この余りになる対のリスト",
            "            r,m = crt(R,C)",
            "            if m!=0:",
            "                ans = min(ans,r)",
            "    if ans==10**30:",
            "        print('infinity')",
            "    else:",
            "        print(ans)",
        ],
        "description": "中国剰余定理(○で割ったら△になる数字を見つける)"
    },
    "floor_sum": {
        "prefix": "floor_sum",
        "body": [
            "# [0,n)の範囲で、y=a/m*x+b/mの下側(直線上含む)にある格子点の数を求める",
            "def floor_sum(n,m,a,b):",
            "    ans=0",
            "    if a>=m:",
            "        ans+=(n-1)*n*(a//m)//2",
            "        a%=m",
            "    if b>=m:",
            "        ans+=n*(b//m)",
            "        b%=m",
            "    y_max=(a*n+b)//m",
            "    x_max=(y_max*m-b)",
            "    if y_max==0:",
            "        return ans",
            "    ans+=(n-(x_max+a-1)//a)*y_max",
            "    ans+=floor_sum(y_max,a,m,(a-x_max%a)%a)",
            "    return ans",
        ],
        "description": "floor_sum"
    },
    "LIS": {
        "prefix": "LIS",
        "body": [
            "from bisect import bisect",
            "",
            "# N: 数列の長さ",
            "# A[i]: a_i の値",
            "def LIS(N, A):",
            "    INF = 10**10",
            "",
            "    dp = [INF]*(N+1)",
            "    dp[0] = -1",
            "    for a in A:",
            "        #idx = bisect(dp, a) #広義最長増加部分列",
            "        idx = bisect(dp, a-1) ",
            "        dp[idx] = min(a, dp[idx])",
            "    return max(i for i in range(N+1) if dp[i] < INF)",
        ],
        "description": "最長増加部分列（LIS）"
    },
    "rotation_matrix": {
        "prefix": "rotation_matrix",
        "body": [
            "import math",
            "#回転前の座標",
            "x = ",
            "y = ",
            "#回転中心の座標(原点の場合は0)",
            "center_x = ",
            "center_y = ",
            "#回転角度(radian)",
            "angle = math.pi*2",
            "#回転後の座標 ",
            "X = math.cos(angle) * (x - center_x) - math.sin(angle) * (y - center_y) + center_x",
            "Y = math.sin(angle) * (x - center_x) + math.cos(angle) * (y - center_y) + center_y",
        ],
        "description": "回転行列"
    },
    "compress_position": {
        "prefix": "compress_position",
        "body": [
            "def compress(arr):",
            "    *XS, = set(arr)",
            "    XS.sort()",
            "    return {e: i for i, e in enumerate(XS)}",
            "",
        ],
        "description": "座標圧縮"
    },
    "counter": {
        "prefix": "counter",
        "body": [
            "from collections import Counter",
            "count = Counter($1)",
        ],
        "description": "数え上げ"
    },
    "defaultdict": {
        "prefix": "defaultdict",
        "body": [
            "from collections import defaultdict",
            "dict = defaultdict(int)",
        ],
        "description": "defaultdict"
    },
    "alphabet": {
        "prefix": "alphabet",
        "body": [
            "alphabet = dict.fromkeys(\"abcdefghijklmnopqrstuvwxyz\",0)",
        ],
        "description": "アルファベットの辞書"
    },
    "chr_and_ord": {
        "prefix": "chr_and_ord",
        "body": [
            "# 0-indexed",
            "def int_to_lower(k):",
            "    return chr(k+97)",
            "",
            "def int_to_upper(k):",
            "    return chr(k+65)",
            "",
            "def lower_to_int(c):",
            "    return ord(c)-97",
            "",
            "def upper_to_int(c):",
            "    return ord(c)-65",
        ],
        "description": "k番目のアルファベットcを相互変換"
    },
    "rolling": {
        "prefix": "rolling",
        "body": [
            "def rolling(s, n):",
            "    l = len(s)",
            "    #右にシフトの場合",
            "    return s[-n%l:] + s[:-n%l] #左にシフトの場合はnの正負を逆に",
        ],
        "description": "文字列sをn文字分右に回転"
    },
    "regular_expression": {
        "prefix": "regular_expression",
        "body": [
            "import re",
            "s = \"testtestest\"",
            "p = re.compile('test')",
            "hit = p.match(s)",
            "find = p.findall(s) # ['test', 'test']",
        ],
        "description": "正規表現"
    },
    "LCS": {
        "prefix": "LCS",
        "body": [
            "def lcs(S, T):",
            "    L1 = len(S)",
            "    L2 = len(T)",
            "    dp = [[0]*(L2+1) for i in range(L1+1)]",
            " ",
            "    for i in reversed(range(L1)):",
            "        for j in reversed(range(L2)):",
            "            r = max(dp[i][j+1], dp[i+1][j])",
            "            if S[i] == T[j]:",
            "                r = max(r, dp[i+1][j+1] + 1)",
            "            dp[i][j] = r",
            "",
            "    # dp[0][0] が長さの解",
            "",
            "    # ここからは復元処理",
            "    res = []",
            "    i = 0; j = 0",
            "    while i < L1 and j < L2:",
            "        if S[i] == T[j]:",
            "            res.append(S[i])",
            "            i += 1; j += 1",
            "        elif dp[i][j] == dp[i+1][j]:",
            "            i += 1",
            "        elif dp[i][j] == dp[i][j+1]:",
            "            j += 1",
            "    return \"\".join(res)",
        ],
        "description": "LCS(最長共通部分列)"
    },

    "LCS_COUNT": {
        "prefix": "LCS_COUNT",
        "body": [
            "def lcs_count(S, T):",
            "    L1 = len(S)",
            "    L2 = len(T)",
            "    dp = [[0]*(L2+2) for i in range(L1+2)]",
            "    sdp = [[0]*(L2+2) for i in range(L1+2)]",
            "    dp[0][0] = 1",
            "    sdp[1][1] = 1",
            " ",
            "    for i in range(L1+1):",
            "        for j in range(L2+1):",
            "            if i == 0 and j == 0:",
            "                continue",
            "            if i-1 >= 0 and j-1 >= 0 and S[i-1] == T[j-1]:",
            "                dp[i][j] = sdp[i][j]",
            "            sdp[i+1][j+1] = (sdp[i+1][j] + sdp[i][j+1] - sdp[i][j] + dp[i][j]) % (10**9+7)",
            "",
            "    # sdp[L1+1][L2+1] が部分文字列の個数",
            "    return sdp[L1+1][L2+1]",
        ],
        "description": "CS(共通部分列)の個数カウント"
    },
    "bisect": {
        "prefix": "bisect",
        "body": [
            "import bisect",
            "'''",
            "bisect.bisect(A,x) #ソートされたリストAにソートを崩さずに値xを挿入するとき、xの入るべきインデックスを返す。",
            "bisect.bisect_left(A,x) #リストAに値xを入れ、xが複数になるとき、一番左の値xのインデックスを返す",
            "bisect.bisect_right(A,x) #リストAに値xを入れ、xが複数になるとき、一番右の値xのインデックスを返す(bisect.bisectと同じ)",
            "'''",
        ],
        "description": "二分探索"
    },
    "meguru_bisect": {
        "prefix": "meguru_bisect",
        "body": [
            "def is_ok(arg):",
            "    # 条件を満たすかどうか？問題ごとに定義",
            "    pass",
            "",
            "def meguru_bisect(ng, ok):",
            "    '''",
            "    初期値のng,okを受け取り,is_okを満たす最小(最大)のokを返す",
            "    まずis_okを定義すべし",
            "    ng ok は  とり得る最小の値-1 とり得る最大の値+1",
            "    最大最小が逆の場合はよしなにひっくり返す",
            "    '''",
            "    while (abs(ok - ng) > 1):",
            "        mid = (ok + ng) // 2",
            "        if is_ok(mid):",
            "            ok = mid",
            "        else:",
            "            ng = mid",
            "    return ok",
        ],
        "description": "めぐる式二分探索"
    },
    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            "from heapq import heappush, heappop",
            "inf=10**18",
            "def dijkstra(d,p,s):",
            "    hq = [(0, s)] # (distance, node)",
            "    seen = [False] * N # ノードが確定済みかどうか",
            "    while hq:",
            "        v = heappop(hq)[1] # ノードを pop する",
            "        seen[v] = True",
            "        for to, cost in adj[v]: # ノード v に隣接しているノードに対して",
            "            if seen[to] == False and d[v] + cost < d[to]:",
            "                d[to] = d[v] + cost",
            "                heappush(hq, (d[to], to))",
            "                p[to] = v",
            "    return dist",
            "",
            "#s→tの最短経路復元",
            "def get_path(t):",
            "    if dist[t] == inf:",
            "        return []",
            "    path = []",
            "    while t != -1:",
            "        path.append(t)",
            "        t = prev[t]",
            "    #t->sの順になっているので逆順にする",
            "    path.reverse()",
            "    return path",
            "",
            "# 入力の受け取り・隣接リストadjの構築：",
            "N,M = map(int, input().split()) # ノード数, エッジ数",
            "adj = [[] for _ in range(N)]",
            "for _ in range(M):",
            "    s,t,d = map(int, input().split())",
            "    s,t = s-1,t-1",
            "    adj[s].append((t, d))",
            "",
            "dist = [inf]*N",
            "dist[0] = 0",
            "prev = [-1]*N",
            "dijkstra(dist,prev,0)",
            "print(dist)",
        ],
        "description": "2点間の最短路をO(ElogV)で求める(負経路はNG)"
    },
    "Bellman_Ford": {
        "prefix": "Bellman_Ford",
        "body": [
            "inf=float(\"inf\")",
            "def bellman_ford(s,n):",
            "    dist = [inf] * n",
            "    dist[s]=0",
            "    for i in range(n):",
            "        for edge in edges:",
            "            if dist[edge[1]] > dist[edge[0]] + edge[2]:",
            "                dist[edge[1]] = dist[edge[0]] + edge[2]",
            "                if i==n-1: return -1",
            "    return dist",
            "",
            "v,e,r = map(int, input().split())",
            "edges = []",
            "for i in range(e):",
            "    s, t, d = map(int, input().split())",
            "    edges.append((s, t, d))",
            "",
            "dist = bellman_ford(r,v)",
        ],
        "description": "２点間の最短路をO(EV)で見つける(負経路もOK)"
    },
    "Warshall–Floyd": {
        "prefix": "Warshall–Floyd",
        "body": [
            "#d[i][j]は2頂点間i, j間の移動コストを格納, Vは頂点数",
            "inf = float(\"INF\")",
            "def warshall_floyd(d,nxt,n):",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                if d[i][k]!=inf and d[k][j]!=inf:",
            "                    if d[i][k] + d[k][j] < d[i][j]:",
            "                        d[i][j] = d[i][k] + d[k][j]",
            "                        nxt[i][j] = nxt[i][k]",
            "                    elif k != i and d[i][k] + d[k][j] == d[i][j]:",
            "                        nxt[i][j] = min(nxt[i][j], nxt[i][k]) #辞書順最小化",
            "",
            "#s→tの最短経路復元",
            "def get_path(s,t):",
            "    if dist[s][t] == inf:",
            "        return []",
            "    path = [s]",
            "    curr = s",
            "    while curr != t:",
            "        curr = nxt[curr][t]",
            "        path.append(curr)",
            "    return path",
            "",
            "#隣接行列で経路を格納",
            "v,e = map(int, input().split())",
            "dist = [[inf]*v for _ in range(v)]",
            "for i in range(e):",
            "    s, t, d = map(int, input().split())",
            "    dist[s][t] = d",
            "#s,tが同じ場合は距離0",
            "for i in range(v):",
            "    dist[i][i] = 0",
            "#経路復元用",
            "nxt = [[0]*v for _ in range(v)]",
            "for i in range(v):",
            "    for j in range(v):",
            "        nxt[i][j] = j",
            "",
            "warshall_floyd(dist,nxt,v)",
            "",
            "#負経路の有無チェック",
            "for i in range(v):",
            "    if dist[i][i] < 0:",
            "        print(\"NEGATIVE CYCLE\")",
            "        exit()",
            "            ",
            "for i in range(v):",
            "    for j in range(v):",
            "        if dist[i][j] == inf:",
            "            dist[i][j] = \"INF\"",
            "    print(*dist[i])",
            "",
            "print(get_path(0,3))",
        ],
        "description": "グラフの全ての頂点の間の最短路をO(V^3)で見つける(負経路もOK)"
    },
    "Union-Find": {
        "prefix": "Union-Find",
        "body": [
            "from collections import defaultdict",
            "",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "",
            "        if x == y:",
            "            return",
            "",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "",
            "    def group_count(self):",
            "        return len(self.roots())",
            "",
            "    def all_group_members(self):",
            "        group_members = defaultdict(list)",
            "        for member in range(self.n):",
            "            group_members[self.find(member)].append(member)",
            "        return group_members",
            "",
            "    def __str__(self):",
            "        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())",
            "'''",
            "uf = UnionFind(N) -> create 6 separated nodes",
            "uf.union(0, 2) -> unite two ids",
            "uf.same(0, 2) -> have same top node?",
            "uf.find(0) -> id of top node",
            "uf.size(5) -> num of group",
            "",
            "# 文字列や任意の数字を要素にしたり復元したい場合",
            "l = ['A', 'B', 'C', 'D', 'E']",
            "",
            "# {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}",
            "d = {x: i for i, x in enumerate(l)}",
            "",
            "# {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E'}",
            "d_inv = {i: x for i, x in enumerate(l)}",
            "",
            "uf.union(d['A'], d['D'])",
            "print(d_inv[uf.find(d['D'])])",
            "# A",
            "'''",
        ],
        "description": "Union-Find"
    },
    "Kruskal": {
        "prefix": "Kruskal",
        "body": [
            "#union-find木",
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.par = [i for i in range(n)] #親",
            "        self.rank = [0 for _ in range(n)] #根の深さ",
            "",
            "    #xの属する木の根を求める",
            "    def find(self, x):",
            "        if self.par[x] == x:",
            "            return x",
            "        else:",
            "            self.par[x] = self.find(self.par[x])",
            "            return self.par[x]",
            "",
            "    #xとyの属する集合のマージ",
            "    def unite(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y:",
            "            return",
            "        if self.rank[x] < self.rank[y]:",
            "            self.par[x] = y",
            "        else:",
            "            self.par[y] = x",
            "            if self.rank[x] == self.rank[y]:",
            "                self.rank[x] += 1",
            "",
            "    #xとyが同じ集合に属するかを判定",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "",
            "#クラスカル法",
            "# V: 頂点集合(リスト) E: 辺集合[始点, 終点, 重み](リスト)",
            "class kruskal():",
            "    def __init__(self, V, E):",
            "        self.V = V",
            "        self.E = E",
            "        self.E.sort(key=lambda x: x[2]) #辺の重みでソート",
            "",
            "    def weight(self): #最小全域木の重み和を求める",
            "        UF = UnionFind(len(V)) #頂点数でUnion Find Treeを初期化",
            "        res = 0",
            "        for i in range(len(self.E)):",
            "            e = self.E[i]",
            "",
            "            if (UF.same(e[0], e[1])) == False:",
            "                UF.unite(e[0], e[1])",
            "                res += e[2]",
            "",
            "        return res",
            "",
            "    def edge(self):",
            "        UF = UnionFind(len(self.V)) #頂点数でUnion Find Treeを初期化",
            "        res_E = []",
            "        for i in range(len(self.E)):",
            "            e = self.E[i]",
            "",
            "            if (UF.same(e[0], e[1])) == False:",
            "                UF.unite(e[0], e[1])",
            "                res_E.append(e)",
            "",
            "        return res_E",
            "",
            "    def node(self):",
            "        UF = UnionFind(len(V)) #頂点数でUnion Find Treeを初期化",
            "        res_V = []",
            "        for i in range(len(E)):",
            "            e = E[i]",
            "",
            "            if (UF.same(e[0], e[1])) == False:",
            "                UF.unite(e[0], e[1])",
            "                res_V.append(e[0])",
            "                res_V.append(e[1])",
            "",
            "        return list(set(res_V))",
            "",
            "v,e = map(int, input().split())",
            "",
            "V = [i for i in range(v)]",
            "E = []",
            "for _ in range(e):",
            "    s,t,w = map(int, input().split())",
            "    E.append((s,t,w))",
            "",
            "k = kruskal(V,E)",
            "print(k.weight())",
        ],
        "description": "最小全域木の辺の重みの総和の算出"
    },
    "BalancingTree": {
        "prefix": "BalancingTree(AVLTree, OrderedSet)",
        "body": [
            "# 順序付きset",
            "class BalancingTree:",
            "    def __init__(self, n):",
            "        self.N = n",
            "        self.root = self.node(1<<n, 1<<n)",
            "",
            "    def append(self, v):# v を追加（その時点で v はない前提）",
            "        v += 1",
            "        nd = self.root",
            "        while True:",
            "            if v == nd.value:",
            "                # v がすでに存在する場合に何か処理が必要ならここに書く",
            "                return 0",
            "            else:",
            "                mi, ma = min(v, nd.value), max(v, nd.value)",
            "                if mi < nd.pivot:",
            "                    nd.value = ma",
            "                    if nd.left:",
            "                        nd = nd.left",
            "                        v = mi",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.left = self.node(mi, p - (p&-p)//2)",
            "                        break",
            "                else:",
            "                    nd.value = mi",
            "                    if nd.right:",
            "                        nd = nd.right",
            "                        v = ma",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.right = self.node(ma, p + (p&-p)//2)",
            "                        break",
            "",
            "    def leftmost(self, nd):",
            "        if nd.left: return self.leftmost(nd.left)",
            "        return nd",
            "",
            "    def rightmost(self, nd):",
            "        if nd.right: return self.rightmost(nd.right)",
            "        return nd",
            "",
            "    def find_l(self, v): # vより真に小さいやつの中での最大値（なければ-1）",
            "        v += 1",
            "        nd = self.root",
            "        prev = 0",
            "        if nd.value < v: prev = nd.value",
            "        while True:",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                prev = nd.value",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "",
            "    def find_r(self, v): # vより真に大きいやつの中での最小値（なければRoot）",
            "        v += 1",
            "        nd = self.root",
            "        prev = 0",
            "        if nd.value > v: prev = nd.value",
            "        while True:",
            "            if v < nd.value:",
            "                prev = nd.value",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "",
            "    @property",
            "    def max(self):",
            "        return self.find_l((1<<self.N)-1)",
            "",
            "    @property",
            "    def min(self):",
            "        return self.find_r(-1)",
            "",
            "    def delete(self, v, nd = None, prev = None): # 値がvのノードがあれば削除（なければ何もしない）",
            "        v += 1",
            "        if not nd: nd = self.root",
            "        if not prev: prev = nd",
            "        while v != nd.value:",
            "            prev = nd",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    #####",
            "                    return",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    #####",
            "                    return",
            "        if (not nd.left) and (not nd.right):",
            "            if not prev.left:",
            "                prev.right = None",
            "            elif not prev.right:",
            "                prev.left = None",
            "            else:",
            "                if nd.pivot == prev.left.pivot:",
            "                    prev.left = None",
            "                else:",
            "                    prev.right = None",
            "",
            "        elif nd.right:",
            "            # print(\"type A\", v)",
            "            nd.value = self.leftmost(nd.right).value",
            "            self.delete(nd.value - 1, nd.right, nd)    ",
            "        else:",
            "            # print(\"type B\", v)",
            "            nd.value = self.rightmost(nd.left).value",
            "            self.delete(nd.value - 1, nd.left, nd)",
            "",
            "    def __contains__(self, v: int) -> bool:",
            "        return self.find_r(v - 1) == v",
            "",
            "    class node:",
            "        def __init__(self, v, p):",
            "            self.value = v",
            "            self.pivot = p",
            "            self.left = None",
            "            self.right = None",
            "",
            "    def debug(self):",
            "        def debug_info(nd_):",
            "            return (nd_.value - 1, nd_.pivot - 1, nd_.left.value - 1 if nd_.left else -1, nd_.right.value - 1 if nd_.right else -1)",
            "",
            "        def debug_node(nd):",
            "            re = []",
            "            if nd.left:",
            "                re += debug_node(nd.left)",
            "            if nd.value: re.append(debug_info(nd))",
            "            if nd.right:",
            "                re += debug_node(nd.right)",
            "            return re",
            "        print(\"Debug - root =\", self.root.value - 1, debug_node(self.root)[:50])",
            "",
            "    def debug_list(self):",
            "        def debug_node(nd):",
            "            re = []",
            "            if nd.left:",
            "                re += debug_node(nd.left)",
            "            if nd.value: re.append(nd.value - 1)",
            "            if nd.right:",
            "                re += debug_node(nd.right)",
            "            return re",
            "        return debug_node(self.root)[:-1]",
            "",
            "'''",
            "BT = BalancingTree(n) # 0 ～ 2^n - 1 までの要素を入れられるピボット木",
            "BT.append(3) # 要素の挿入",
            "BT.delete(20) # 要素の削除",
            "BT.find_l(12) # 要素より真に小さいやつの中での最大値（なければ-1）",
            "BT.find_r(5) # 要素より真に大きいやつの中での最小値（なければRoot）",
            "BT.min # 格納要素中の最小値",
            "BT.max # 格納要素中の最大値",
            "3 in BT # 格納要素中の存在判定",
            "print(BT.debug_list) # 格納された要素一覧の出力",
            "'''",
        ],
        "description": "平衡二分木(順序付きset)"
    },
    "Chu_Liu_Edmonds": {
        "prefix": "Chu_Liu_Edmonds",
        "body": [
            "from heapq import heappush, heappop",
            "def chu_liu_edmonds(v,edges,r):",
            "    if v <= 1:",
            "        return 0",
            "    q = [[] for _ in range(0, v)]",
            "    for s, t, w in edges:",
            "        heappush(q[t], (w, s))",
            "    M = [(0, -1) for _ in range(0, v)]",
            "    for t in range(0, v):",
            "        if t != r:",
            "            w, s = heappop(q[t])",
            "            M[t] = (w, s)",
            "    ",
            "    used = [False for _ in range(0, v)]",
            "    hist = []",
            "    cycle = []",
            "    for t in range(0, v):",
            "        w, s = M[t]",
            "        if s == -1 or used[t] == True:",
            "            continue",
            "        if used[t] == False:",
            "            used[t] = True",
            "            hist += [t]",
            "            tt = s",
            "            while used[tt] == False:",
            "                used[tt] = True",
            "                hist += [tt]",
            "                w, s = M[tt]",
            "                if s == -1:",
            "                    hist = []",
            "                    break",
            "                tt = s",
            "            if used[tt] == True and s != -1 and 0 < len(hist):",
            "                try:",
            "                    k = hist.index(tt)",
            "                    cycle = hist[k:]",
            "                except:",
            "                    continue",
            "                finally:",
            "                    pass",
            "                break",
            "                ",
            "    if len(cycle) == 0:",
            "        return sum(m[0] for m in M)",
            "",
            "    parent = min(cycle)",
            "    rn = [0 for _ in range(0, v)]",
            "    k = 0",
            "    for t in range(0, v):",
            "        if k == parent:",
            "            k += 1",
            "        if t in cycle:",
            "            rn[t] = parent",
            "        else:",
            "            rn[t] = k",
            "            k += 1",
            "            ",
            "    Vp = v - len(cycle) + 1",
            "    Ep = []",
            "    for s, t, w in edges:",
            "        if s in cycle:",
            "            if t in cycle:",
            "                continue",
            "            else:",
            "                Ep += [[parent, rn[t], w]]",
            "        else:",
            "            if t in cycle:",
            "                Ep += [[rn[s], parent, w - M[t][0]]]",
            "            else:",
            "                Ep += [[rn[s], rn[t], w]]",
            "    r = rn[r]",
            "    return chu_liu_edmonds(Vp, Ep, r) + sum(M[t][0] for t in cycle)",
            "",
            "v,e,r = map(int, input().split())",
            "edges = []",
            "for _ in range(e):",
            "    s, t, w = map(int, input().split())",
            "    edges.append((s, t, w))",
            "",
            "print(chu_liu_edmonds(v, edges, r))",
        ],
        "description": "#最小全域有向木の辺の重みの総和を求める"
    },
    "tree_diameter": {
        "prefix": "tree_diameter",
        "body": [
            "# N: 木Tの頂点数",
            "# G[u] = [(w, c), ...]:",
            "#   頂点uに隣接する頂点wとそれを繋ぐ辺の長さc",
            "from collections import deque",
            "def tree_diameter(s):",
            "    dist = [None]*N",
            "    que = deque([s])",
            "    dist[s] = 0",
            "    while que:",
            "        v = que.popleft()",
            "        d = dist[v]",
            "        for w, c in G[v]:",
            "            if dist[w] is not None:",
            "                continue",
            "            dist[w] = d + c",
            "            que.append(w)",
            "    d = max(dist)",
            "    return dist.index(d), d",
            "",
            "u, _ = tree_diameter(0)",
            "v, d = tree_diameter(u)",
            "# パスu-vがこの木Tの直径(長さd)",
        ],
        "description": "木の直径"
    },
    "LowLink": {
        "prefix": "LowLink",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def get_articulation_points(adj, n, start=0):",
            "    order = [None]*n",
            "    result = []; count = 0",
            "    def dfs(v, prev):",
            "        nonlocal count",
            "        r_min = order[v] = count # 到達時にラベル",
            "        fcnt = 0; p_art = 0",
            "        count += 1",
            "        for w in adj[v]:",
            "            if w == prev:",
            "                continue",
            "            if order[w] is None:",
            "                ret = dfs(w, v)",
            "                # 子の頂点が到達できたのが、自身のラベル以上の頂点のみ",
            "                # => 頂点vは関節点",
            "                p_art |= (order[v] <= ret)",
            "                r_min = min(r_min, ret)",
            "                fcnt += 1",
            "            else:",
            "                r_min = min(r_min, order[w])",
            "        p_art |= (r_min == order[v] and len(adj[v]) > 1)",
            "        if (prev == -1 and fcnt > 1) or (prev != -1 and p_art):",
            "            # 頂点startの場合は、二箇所以上の子頂点を調べたら自身は関節点",
            "            result.append(v)",
            "        return r_min",
            "    dfs(start, -1)",
            "    return result",
            "",
            "v,e = map(int, input().split())",
            "adj = [[] for i in range(v)]",
            "for _ in range(e):",
            "    s, t = map(int, input().split())",
            "    adj[s].append(t)",
            "    adj[t].append(s)",
            "    ",
            "ans = sorted(get_articulation_points(adj, v, start=0))",
        ],
        "description": "無向グラフの関節点(Articulation Points)の算出"
    },
    "Bridge": {
        "prefix": "Bridge",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "def bridge(adj, n):",
            "    result = set()",
            "    label = [None]*n",
            "    gen = 0",
            "    cost = [0]*n",
            "    def dfs(u, p):",
            "        nonlocal gen",
            "        res = 0",
            "        for v in adj[u]:",
            "            if v == p:",
            "                continue",
            "            if label[v] is not None:",
            "                if label[v] < label[u]:",
            "                    cost[v] += 1",
            "                    res += 1",
            "            else:",
            "                label[v] = gen; gen += 1",
            "                r = dfs(v, u)",
            "                if r == 0:",
            "                    result.add((u, v) if u < v else (v, u))",
            "                res += r",
            "        res -= cost[u]",
            "        return res",
            "    for v in range(n):",
            "        if not label[v]:",
            "            label[v] = gen; gen += 1",
            "            r = dfs(v, -1)",
            "            assert r == 0, r",
            "    return result",
            "",
            "v,e = map(int, input().split())",
            "adj = [[] for i in range(v)]",
            "for _ in range(e):",
            "    s, t = map(int, input().split())",
            "    adj[s].append(t)",
            "    adj[t].append(s)",
            "    ",
            "ans = sorted(bridge(adj, v))",
        ],
        "description": "グラフの橋(除去するとグラフが連結でなくなる辺)を検出"
    },
    "dfs": {
        "prefix": "dfs",
        "body": [
            "# Pythonで提出！！",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "move = ([1, 0], [-1, 0], [0, 1], [0, -1])",
            "land = 0",
            "sea = 0",
            "def dfs(x, y):",
            "    global land",
            "    global sea",
            "    islands[y][x] = \"F\" #カウント済",
            "    for dy, dx in move:",
            "        nx = x + dx",
            "        ny = y + dy",
            "        if nx > -1 and nx < W and ny > -1 and ny < H:",
            "            if islands[ny][nx] == \".\": #海の場合",
            "                sea += 1",
            "            elif islands[ny][nx] == '#': #陸地の場合",
            "                land += 1",
            "                dfs(nx, ny)",
        ],
        "description": "地続きの島とその周りの海に面した辺をカウント"
    },
    "dfs_euler_tour": {
        "prefix": "dfs_euler_tour",
        "body": [
            "# Pythonで提出！！",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "def dfs(s,pre):",
            "  ans.append(s+1)",
            "  for to in graph[s]:",
            "    if to != pre: # to == preが葉(末端ノード)を表す",
            "      dfs(to,s)",
            "      ans.append(s+1)",
            "",
            "N,M = map(int,input().split())",
            "graph = [[] for _ in range(N)]",
            "for i in range(M):",
            "  a,b = map(int,input().split())",
            "  a,b = a-1,b-1",
            "  graph[a].append(b)",
            "  graph[b].append(a)",
            "",
            "for i in range(N):",
            "    graph[i].sort()",
            "",
            "ans=[]",
            "dfs(0,-1)",
            "print(*ans)",
            "",
        ],
        "description": "Euler Tour(深さ優先探索で辿った経路の出力)"
    },
    "dfs_stairs": {
        "prefix": "dfs_stairs",
        "body": [
            "# Pythonで提出！！",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def dfs(n):",
            "    if n == N:",
            "        return 1",
            "    if seen[n]:",
            "        return seen[n]",
            "",
            "    if n+L <= N:",
            "        seen[n] = (seen[n]+dfs(n+L)+dfs(n+1))%(10**9+7)",
            "    elif n+1 <= N:",
            "        seen[n] = (seen[n]+dfs(n+1))%(10**9+7)",
            "",
            "    return seen[n]",
            "",
            "N,L = map(int,input().split())",
            "seen = [0]*(N+1)",
            "print(dfs(0))",
        ],
        "description": "階段の上り方(1段orL段)の数え上げ"
    },
    "bfs_maze": {
        "prefix": "bfs_maze",
        "body": [
            "from collections import deque",
            "",
            "move = ([1, 0], [-1, 0], [0, 1], [0, -1])",
            "#move = ([-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]) #縦横斜め移動",
            "#歩数カウント不要ならvisited = set([])として、都度visited.add(new_x+new_y*C)して管理する方法も可",
            "def bfs(sy, sx, gy, gx):",
            "    queue = deque([[sy, sx]])",
            "    visited = [[-1]*C for j in range(R)]",
            "    visited[sy][sx] = 0",
            "    while queue:",
            "        y, x = queue.popleft()",
            "        if [y, x] == [gy, gx]:",
            "            return visited[y][x]",
            "        for dy, dx in move:",
            "            new_y, new_x = y+dy, x+dx",
            "            if maze[new_y][new_x] == \".\" and visited[new_y][new_x] == -1:",
            "                visited[new_y][new_x] = visited[y][x] + 1",
            "                queue.append([new_y, new_x])",
            "",
            "R, C = map(int, input().split())",
            "sy, sx = map(int, input().split())",
            "gy, gx = map(int, input().split())",
            "sy, sx, gy, gx = sy-1, sx-1, gy-1, gx-1",
            "",
            "maze = [input() for i in range(R)]",
            "print(bfs(sy, sx, gy, gx))",
        ],
        "description": "迷路の探索(縦横移動のみ、周囲は全て壁、必ずGにたどり着ける前提)"
    },
    "bfs_graph": {
        "prefix": "bfs_graph",
        "body": [
            "from collections import deque",
            "",
            "def bfs(dist):",
            "    queue = deque()",
            "    queue.append(0)",
            "    while queue:",
            "        s = queue.popleft()",
            "        for to in graph[s]:",
            "            if dist[to] != -1:",
            "                continue",
            "            dist[to] = dist[s] + 1",
            "            queue.append(to)",
            "",
            "N,M = map(int, input().split())",
            "",
            "graph = [[] for _ in range(N)]",
            "for i in range(M):",
            " a,b = map(int, input().split())",
            " a,b = a-1,b-1",
            " graph[a].append(b)",
            " graph[b].append(a)",
            "",
            "dist = [-1]*N",
            "dist[0] = 0",
            "bfs(dist)",
            "",
        ],
        "description": "グラフの幅優先探索 O(N+M)"
    },
    "cumsum": {
        "prefix": "cumsum",
        "body": [
            "import itertools",
            "import operator",
            "cumsum = [0] + list(itertools.accumulate($1, func=operator.add))",
        ],
        "description": "累積和"
    },
    "cumsum_2d": {
        "prefix": "cumsum_2d",
        "body": [
            "H,W = map(int,input().split())",
            "A = [list(map(int,input().split())) for _ in range(H)]",
            "",
            "cumsum = [[0]*(W+1) for _ in range(H+1)]",
            "for y in range(H):",
            "    for x in range(W):",
            "        cumsum[y+1][x+1] = cumsum[y][x+1] + cumsum[y+1][x] - cumsum[y][x] + A[y][x]",
            "",
            "print(*cumsum,sep=\"\\n\")",
            "print(cumsum[H][W]-cumsum[1][1])",
        ],
        "description": "二次元累積和"
    },
    "imos": {
        "prefix": "imos",
        "body": [
            "enter = [3, 4, 5]",
            "exit = [7, 6, 8]",
            "N = 3",
            "last_exit = max(exit)",
            "table = [0] * (last_exit + 1)",
            "",
            "# 入退店のカウント",
            "for i in range(N):",
            "  table[enter[i]] += 1",
            "  table[exit[i]] -= 1",
            "",
            "# シミュレート(累積和)",
            "for i in range(1, last_exit):",
            "  table[i] += table[i - 1]",
            "",
            "print(table)",
        ],
        "description": "いもす法"
    },
    "imos_2d": {
        "prefix": "imos_2d",
        "body": [
            "N = int(input())",
            "H=W=1001",
            "A = [[0]*W for _ in range(H)]",
            "for _ in range(N):",
            "    lx,ly,rx,ry = map(int,input().split())",
            "    A[ly][lx] += 1",
            "    A[ry][rx] += 1",
            "    A[ry][lx] -= 1",
            "    A[ly][rx] -= 1",
            "",
            "for y in range(H):",
            "    for x in range(1,W):",
            "        A[y][x] += A[y][x-1]",
            "",
            "for y in range(1,H):",
            "    for x in range(W):",
            "        A[y][x] += A[y-1][x]",
            "",
            "ans = [0]*N",
            "for y in range(H):",
            "    for x in range(W):",
            "        if 0 < A[y][x] <= N:",
            "            ans[A[y][x]-1] += 1",
            "for a in ans:",
            "    print(a)",
        ],
        "description": "二次元いもす法"
    },
    "syakutori": {
        "prefix": "syakutori",
        "body": [
            "from collections import deque",
            "q=deque()",
            "for c in a:",
            "    q.append(c)  ## dequeの右端に要素を一つ追加する。",
            "    (追加した要素に応じて何らかの処理を行う)",
            "",
            "    while not (満たすべき条件):",
            "        rm=q.popleft() ## 条件を満たさないのでdequeの左端から要素を取り除く",
            "        (取り除いた要素に応じて何らかの処理を行う)",
            "",
            "    (何らかの処理を行う。whileがbreakしたので、dequeに入っている連続部分列は条件を満たしている。特に右端の要素から左に延ばせる最大の長さになっている。)",
        ],
        "description": "しゃくとり法"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "# BIT(Fenwick Tree) ※一点加算、区間和のRSQ相当",
            "class BIT:",
            "    def __init__(self, n):",
            "        self._n = n",
            "        self.data = [0] * n",
            "",
            "    def add(self, p, x):",
            "        assert 0 <= p < self._n",
            "        p += 1",
            "        while p <= self._n:",
            "            self.data[p - 1] += x",
            "            p += p & -p",
            "",
            "    def sum(self, l, r):",
            "        assert 0 <= l <= r <= self._n",
            "        return self._sum(r) - self._sum(l)",
            "",
            "    def _sum(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s += self.data[r - 1]",
            "            r -= r & -r",
            "        return s",
            "",
            "'''",
            "bit = BIT(5) # 要素数5個の配列を0で初期化",
            "bit.add(1,3) # bit[1]に3を加算",
            "bit.add(2,5) # bit[2]に5を加算",
            "print(bit.sum(1,3)) # インデックス1から2(半閉半開区間)の要素の合計(=8)を取得",
            "print(bit.data) # [0,3,5,8,0]",
            "'''",
        ],
        "description": "Binary Indexed Tree(Fenwick Tree)　※一点加算、区間和のRSQ相当"
    },
    "SegTree_Abstract": {
        "prefix": "SegTree_Abstract",
        "body": [
            "# 区間に行う操作(最小値:min、最大値:max、区間和:x+y、区間積:x*y、最大公約数:gcd)",
            "def segfunc(x, y):",
            "    return min(x, y)",
            "",
            "#単位元(最小値:inf、最大値:-inf、区間和:0、区間積:1、最大公約数:0)",
            "ide_ele = float('inf')",
            "",
            "class SegTree:",
            "    \"\"\"",
            "    init(init_val, segfunc,ide_ele): 配列init_valで初期化 O(N)",
            "    update(k, x): k番目の値をxに更新 O(N)",
            "    query(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)",
            "    \"\"\"",
            "    def __init__(self, init_val, segfunc, ide_ele):",
            "        \"\"\"",
            "        n: 要素数",
            "        num: n以上の最小の2のべき乗",
            "        tree: セグメント木(1-index)",
            "        \"\"\"",
            "        n = len(init_val)",
            "        self.segfunc = segfunc",
            "        self.ide_ele = ide_ele",
            "        self.num = 1 << (n - 1).bit_length()",
            "        self.tree = [ide_ele] * 2 * self.num",
            "        # 配列の値を葉にセット",
            "        for i in range(n):",
            "            self.tree[self.num + i] = init_val[i]",
            "        # 構築していく",
            "        for i in range(self.num - 1, 0, -1):",
            "            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
            "",
            "    def update(self, k, x):",
            "        \"\"\"",
            "        k番目の値をxに更新",
            "        k: index(0-index)",
            "        x: update value",
            "        \"\"\"",
            "        k += self.num",
            "        self.tree[k] = x",
            "        while k > 1:",
            "            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
            "            k >>= 1",
            "",
            "    def query(self, l, r):",
            "        \"\"\"",
            "        [l, r)のsegfuncしたものを得る",
            "        l: index(0-index)",
            "        r: index(0-index)",
            "        \"\"\"",
            "        res = self.ide_ele",
            "",
            "        l += self.num",
            "        r += self.num",
            "        while l < r:",
            "            if l & 1:",
            "                res = self.segfunc(res, self.tree[l])",
            "                l += 1",
            "            if r & 1:",
            "                res = self.segfunc(res, self.tree[r - 1])",
            "            l >>= 1",
            "            r >>= 1",
            "        return res",
            "",
            "seg = SegTree(, segfunc, ide_ele)",
            "'''",
            "print(seg.query(0, 8))",
            "seg.update(5, 0)",
            "print(seg.query(0, 8))",
            "'''",
        ],
        "description": "抽象化セグメント木"
    },
    "knapsack": {
        "prefix": "knapsack",
        "body": [
            "N,W = map(int,input().split())",
            "goods = [list(map(int,input().split())) for _ in range(N)]",
            "",
            "dp = [[0]*(W+1) for i in range(N+1)]",
            "",
            "for i in range(N):",
            "    for j in range(W+1):",
            "        if j-goods[i][0] >= 0:",
            "            dp[i][j] = max(dp[i-1][j], dp[i-1][j-goods[i][0]] + goods[i][1])",
            "        else:",
            "            dp[i][j] = dp[i-1][j]",
            "",
            "print(dp[N-1][W])",
        ],
        "description": "ナップサック(重複なし)"
    },
}