{
    "input_graph": {
        "scope": "rust",
        "prefix": "input_graph",
        "body": [
            "input! {",
            "    N: usize,",
            "    M: usize,",
            "    edges: [(Usize1, Usize1); M]",
            "}",
            "",
            "let mut graph = vec![vec![];N];",
            "for &(A,B) in &edges{",
            "    graph[A].push(B);",
            "    graph[B].push(A);",
            "}",
            "",
        ],
        "description": "N頂点M辺のグラフの入力"
    },
    "print":{
		"scope": "rust",
        "prefix":"print",
		"body":["println!(\"{}\",$1);"],
		"description":"print",
	},
    "print_list":{
		"scope": "rust",
        "prefix":"print_list",
		"body":["println!(\"{}\",$1.iter().join(\" \"));"],
		"description":"print",
	},
    "print_list_to_string": {
        "prefix": "print_list_to_string",
        "body": [
            "println!(\"{}\",$1.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(\" \"));",
        ],
        "description": "print(数値→文字列)"
    },
    "print_list2d":{
		"scope": "rust",
        "prefix":"print_list2d",
		"body":["println!(\"{}\",$1.iter().map(|x| x.iter().join(\" \")).join(\"\\n\"));"],
		"description":"print",
	},
    "print_YesNo": {
        "scope": "rust",
        "prefix": "print_YesNo",
        "body": [
            "if $1 {",
            "    println!(\"Yes\");",
            "}else{",
            "    println!(\"No\");",
            "}",
        ],
        "description": "print_YesNo"
    },
    "print_debug": {
        "scope": "rust",
        "prefix": "print_debug",
        "body": [
            "eprintln!(\"{:?}\",$1);",
        ],
        "description": "printデバッグ(標準エラー出力)"
    },
    "debug": {
        "scope": "rust",
        "prefix": "debug_comment",
        "body": [
            "dbg!($1)",
        ],
        "description": "デバッグ用コメント出力マクロ"
    },
    "cumsum": {
        "scope": "rust",
        "prefix": "cumsum",
        "body": [
            "let mut cumsum = vec![0];",
            "for i in 0..N{",
            "    cumsum.push(cumsum[i] + A[i])",
            "}",
        ],
        "description": "累積和"
    },
    "cumsum_2d": {
        "scope": "rust",
        "prefix": "cumsum_2d",
        "body": [
            "let mut cumsum = vec![vec![0;W+1];H+1];",
            "",
            "for i in 0..H{",
            "    for j in 0..W{",
            "        cumsum[i+1][j+1] = A[i][j];",
            "    }",
            "}",
            "",
            "for i in 0..H{",
            "    for j in 0..W{",
            "        cumsum[i+1][j+1] += cumsum[i+1][j] + cumsum[i][j+1] - cumsum[i][j];",
            "    }",
            "}",
            "",
            "for (L1,R1,L2,R2) in query{",
            "    println!(\"{}\",cumsum[L2][R2] - cumsum[L1-1][R2] - cumsum[L2][R1-1] + cumsum[L1-1][R1-1]);",
            "}",
        ],
        "description": "二次元累積和"
    },
    "imos": {
        "scope": "rust",
        "prefix": "imos",
        "body": [
            "let mut imos = vec![0;D+1];",
            "for (L,R) in p{",
            "    imos[L-1] += 1;",
            "    imos[R] -= 1;",
            "}",
            "",
            "let mut cumsum = vec![0];",
            "for i in 0..D{",
            "    cumsum.push(cumsum[i] + imos[i]);",
            "    println!(\"{}\",cumsum[i+1]);",
            "}",
            "",
        ],
        "description": "いもす法"
    },
    "imos_2d": {
        "scope": "rust",
        "prefix": "imos_2d",
        "body": [
            "let mut imos = vec![vec![0;W+1];H+1];",
            "for t in 0..N{",
            "    let (A,B,C,D) = query[t];",
            "    imos[A][B] += 1;",
            "    imos[A][D+1] -= 1;",
            "    imos[C+1][B] -= 1;",
            "    imos[C+1][D+1] += 1;",
            "}",
            "",
            "let mut cumsum = vec![vec![0;W+1];H+1];",
            "",
            "for i in 0..H{",
            "    for j in 0..W{",
            "        cumsum[i+1][j+1] = imos[i][j];",
            "    }",
            "}",
            "",
            "for i in 0..H{",
            "    for j in 0..W{",
            "        cumsum[i+1][j+1] += cumsum[i+1][j] + cumsum[i][j+1] - cumsum[i][j];",
            "    }",
            "}",
            "",
            "for i in 1..=H{",
            "    println!(\"{}\",&cumsum[i][1..].iter().map(|x| x.to_string()).collect::<Vec<_>>().join(\" \"));",
            "}",
        ],
        "description": "二次元いもす法"
    }
    ,
    "meguru_bisect": {
        "scope": "rust",
        "prefix": "meguru_bisect",
        "body": [
            "fn is_ok(mid: isize, X:usize, A:&Vec<usize>) -> bool {",
            "    // 問題ごとに引数・条件を定義する。",
            "    if A[mid as usize] > X{",
            "        return true;",
            "    }else{",
            "        return false;",
            "    } ",
            "}",
            "",
            "// 初期値のng,okを受け取り,is_okを満たす最小(最大)のokを返す。",
            "// まずis_okを定義すべし。",
            "// ng ok は  とり得る最小の値-1 とり得る最大の値+1。",
            "// 最大最小が逆の場合はよしなにひっくり返す。",
            "let mut ok:isize = ok;",
            "let mut ng:isize = ng;",
            "while (ok-ng).abs() > 1{",
            "    let mid:isize = (ok + ng)/2;",
            "    if is_ok(mid,X,&A){",
            "        ok = mid;",
            "    }else{",
            "        ng = mid;",
            "    }",
            "}",
        ],
        "description": "めぐる式二分探索"
    },
    "syakutori": {
        "scope": "rust",
        "prefix": "syakutori",
        "body": [
            "let mut q:VecDeque<usize> = VecDeque::new();",
            "for &c in &A{",
            "    q.push_back(c); //dequeの右端に要素を一つ追加する。",
            "    //(追加した要素に応じて何らかの処理を行う)",
            "",
            "    while !(q[q.len()-1]-q[0] <= K){",
            "        let rm = q.pop_front().unwrap(); //条件を満たさないのでdequeの左端から要素を取り除く",
            "        //(取り除いた要素に応じて何らかの処理を行う)",
            "    }",
            "",
            "    //(何らかの処理を行う。whileがbreakしたので、dequeに入っている連続部分列は条件を満たしている。特に右端の要素から左に延ばせる最大の長さになっている。)",
            "    if q.len() >= 2{",
            "        ans += q.len()-1;",
            "    }",
            "}",
        ],
        "description": "しゃくとり法"
    },
    "deque": {
        "scope": "rust",
        "prefix": "deque",
        "body": [
            "let mut deque:VecDeque<usize> = VecDeque::new();"
            "//deque.extend(vec) //既存のvecで初期化する場合",
        ],
        "description": "deque"
    },
    "heapq": {
        "scope": "rust",
        "prefix": "heapq",
        "body": [
            "let mut heap = BinaryHeap::new(); //RustのBinaryHeapは最大値をpopする。",
            "heap.push(0);",
            "heap.push(1);",
            "",
            "let peek = *heap.peek().unwrap(); //参照のみ。popしない。",
            "let a = heap.pop().unwrap();",
            "",
            "// // 最小値をpop",
            "// let mut heap_min = BinaryHeap::from(vec![Reverse(0),Reverse(1)]);",
            "",
            "// let peek = heap_min.peek().unwrap().0; //参照のみ。popしない。",
            "// let a = heap_min.pop().unwrap().0;",
        ],
        "description": "heapq(優先度付きキュー)"
    },
    "SortedSet": {
        "scope": "rust",
        "prefix": "SortedSet",
        "body": [
            "let mut ss = BTreeSet::new();",
            "ss.insert(9);",
            "ss.contains(9); // True",
            "ss.remove(9);",
        ],
        "description": "SortedSet(順序付きset)。重複を許さない。"
    },
    "SortedMultiSet": {
        "scope": "python",
        "prefix": "SortedMultiSet",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
            "import math",
            "from bisect import bisect_left, bisect_right, insort",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedMultiset(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(a)",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedMultiset\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def count(self, x: T) -> int:",
            "        \"Count the number of x.\"",
            "        return self.index_right(x) - self.index(x)",
            "",
            "    def add(self, x: T) -> None:",
            "        \"Add an element. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return",
            "        a = self._find_bucket(x)",
            "        insort(a, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": "SortedMultiSet(順序付きマルチセット)。重複を許す。"
    },
    "sort_with_index": {
        "scope": "python",
        "prefix": "sort_with_index",
        "body": [
            "def sort_with_index(arr, reverse=False):",
            "    if reverse:",
            "        return sorted([ (x,i) for i, x in enumerate(arr)], reverse=True)",
            "    else:",
            "        return sorted([ (x,i) for i, x in enumerate(arr)])",
        ],
        "description": "index付きソート"
    },
    "sort_multiple": {
        "scope": "python",
        "prefix": "sort_multiple",
        "body": [
            "# 昇順降順を入れ替える場合はlambda式の正負を反転",
            "$1.sort(key=lambda x:(-x[1],x[0]))",
        ],
        "description": "多次元リストのソート"
    },
    "rotate_2d": {
        "scope": "python",
        "prefix": "rotate_2d",
        "body": [
            "# 二次元配列の90度右回転",
            "def rotate_2d(arr):",
            "    return list(zip(*arr[::-1]))",
            "",
        ],
        "description": "二次元配列の90度右回転"
    },
    "inverse_2d": {
        "scope": "python",
        "prefix": "inverse_2d",
        "body": [
            "inv = list(zip(*$1))",
        ],
        "description": "二次元配列の転置"
    },
    "RunLengthEncoding": {
        "scope": "python",
        "prefix": "RunLengthEncoding",
        "body": [
            "def RunLengthEncoding(S):",
            "    cur = S[0]",
            "    cnt = 1",
            "    res = []",
            "    for i in range(1,len(S)):",
            "        if cur == S[i]:",
            "            cnt += 1",
            "        else:",
            "            res.append((cur,cnt))",
            "            cur = S[i]",
            "            cnt = 1",
            "    res.append((cur,cnt))",
            "    return res",
        ],
        "description": "ランレングス圧縮"
    },
    "baisuu": {
        "scope": "rust",
        "prefix": "baisuu",
        "body": [
            "2の倍数：1の位が2,4,6,8,0",
            "3の倍数：各桁の数字の和が3の倍数",
            "4の倍数：下2桁が4の倍数",
            "5の倍数：1の位が5,0",
            "6の倍数：2の倍数かつ3の倍数",
            "7の倍数：3桁ごとに区切った数字を1つ飛ばしに足した和の差が7の倍数",
            "8の倍数：下3桁が8の倍数",
            "9の倍数：各桁の数字の和が9の倍数",
            "11の倍数：(奇数桁目の数字の和)-(偶数桁目の数字の和)が11の倍数か0",
            "13の倍数：3桁ごとに区切った数字を1つ飛ばしに足した和の差が13の倍数",
        ],
        "description": "倍数判別法"
    },
    "ceil": {
        "scope": "rust",
        "prefix": "ceil",
        "body": [
            "// Xはi64",
            "if (X + 9) < 0 && (X + 9) % 10 != 0 {",
            "    println!(\"{}\", (X + 9) / 10 - 1);",
            "} else {",
            "    println!(\"{}\", (X + 9) / 10);",
            "}",
        ],
        "description": "ceil(切り上げ除算)"
    },
    "mod_1000000007": {
        "scope": "rust",
        "prefix": "mod_1000000007",
        "body": [
            "const MOD: usize = 1_000_000_007;",
        ],
        "description": "数え上げでよく使う数値その1"
    },
    "mod_998244353": {
        "scope": "rust",
        "prefix": "mod_998244353",
        "body": [
            "const MOD: usize = 998_244_353",
        ],
        "description": "数え上げでよく使う数値その2"
    },
    "round_half_up": {
        "scope": "python",
        "prefix": "round_half_up",
        "body": [
            "from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN",
            "f = 123.456",
            "print(Decimal(str(f)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))",
            "#123",
            "print(Decimal(str(f)).quantize(Decimal('0.1'), rounding=ROUND_HALF_UP))",
            "#123.5",
            "print(Decimal(str(f)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
            "#123.46",
        ],
        "description": "四捨五入"
    },
    "gcd": {
        "scope": "rust",
        "prefix": "gcd",
        "body": [
            "fn gcd(a: usize, b: usize) -> usize {",
            "    if b == 0 {",
            "        a",
            "    } else {",
            "        gcd(b, a % b)",
            "    }",
            "}",
            "",
            "fn gcd_list(list: &[usize]) -> usize {",
            "    list.iter().fold(list[0], |a, b| gcd(a, *b))",
            "}",
        ],
        "description": "a,bの最大公約数"
    },
    "lcm": {
        "scope": "rust",
        "prefix": "lcm",
        "body": [
            "fn gcd(a: usize, b: usize) -> usize {",
            "    if b == 0 {",
            "        a",
            "    } else {",
            "        gcd(b, a % b)",
            "    }",
            "}",
            "",
            "fn lcm(a: usize, b: usize) -> usize {",
            "    a / gcd(a, b) * b",
            "}",
            "",
            "fn lcm_list(list: &[usize]) -> usize {",
            "    list.iter().fold(list[0], |a, b| lcm(a, *b))",
            "}",
        ],
        "description": "a,bの最小公倍数"
    },
    "digsum": {
        "scope": "python",
        "prefix": "digsum",
        "body": [
            "def digsum(n):",
            "    res = 0",
            "    while n > 0:",
            "        res += n%10",
            "        n //= 10",
            "    ",
            "    return res",
        ],
        "description": "桁和"
    },
    "base_n": {
        "scope": "rust",
        "prefix": "base_n",
        "body": [
            "# 10進数⇒2,8,16進数",
            "x = 10",
            "bin_x = bin(x)[2:]",
            "oct_x = oct(x)[2:]",
            "hex_x = hex(x)[2:]",
            "",
            "//10進数⇒n進数",
            "fn base10int(value:usize,base:usize) -> String{",
            "    let quotient = value/base;",
            "    let remainder = value%base;",
            "    if value >= base{",
            "        return base10int(quotient, base) + &std::char::from_digit(remainder as u32, base as u32).unwrap().to_string().to_uppercase()",
            "    }",
            "    return std::char::from_digit(remainder as u32, base as u32).unwrap().to_string().to_uppercase();",
            "}",
            "",
            "# 10進数⇒n進数(返り値リスト)",
            "def base10int_list(value, base):",
            "    upper = value >= base and base10int_list(value // base, base) or []",
            "    return upper + [value % base]  # リストの結合",
            "",
            "//n進数⇒10進数",
            "//2<=n<=36の時は、Rust組み込みのfrom_str_radix関数を使用",
            "let ans = i32::from_str_radix(&N, base).unwrap()",
            "",
            "# 前処理として、各桁の値を格納したリストが必要",
            "# digits = list(str(value))",
            "def decode(digits, base):",
            "    value = 0",
            "    for digit in digits:",
            "        value = value * base + int(digit)",
            "    return value",
            "",
        ],
        "description": "進数変換"
    },
    "divisor": {
        "scope": "rust",
        "prefix": "divisor",
        "body": [
            "fn divisor(n:usize) -> Vec<usize>{",
            "    let mut res = vec![];",
            "    for i in (1..).take_while(|x| x*x <= n){",
            "        if n%i == 0{",
            "            res.push(i);",
            "            if i*i != n{",
            "                res.push(n/i);",
            "            }",
            "        }",
            "    }",
            "    res.sort();",
            "    return res;",
            "}",
        ],
        "description": "nの約数を全て求める(O(√N))"
    },
    "mcb": {
        "scope": "python",
        "prefix": "mcb",
        "body": [
            "def mcb(N):",
            "    L,R = 1, 10**5+1 # Nの桁数によってRの桁数も変化(例：N=10^15　⇒　R=10^5+1)",
            "    while R-L > 1:",
            "        mid=(L+R)/2",
            "        if mid*mid*mid <= N:",
            "            L=mid",
            "        else:",
            "            R=mid",
            "    return L",
        ],
        "description": "三乗根"
    },
    "prime_decomposition": {
        "scope": "rust",
        "prefix": "prime_decomposition",
        "body": [
            "fn prime_decomposition(mut n:usize) -> Vec<usize> {",
            "    let mut i = 2;",
            "    let mut table = vec![];",
            "    while i*i <= n{",
            "        while n%i == 0{",
            "            n /= i;",
            "            table.push(i);",
            "        }",
            "        i += 1;",
            "    }",
            "    if n > 1{",
            "        table.push(n);",
            "    }",
            "    return table;",
            "}",
        ],
        "description": "nを素因数分解したリストを返す"
    },
    "is_prime": {
        "scope": "rust",
        "prefix": "is_prime",
        "body": [
            "fn is_prime(n: usize) -> bool {",
            "    n != 1 && (2..).take_while(|i| i*i <= n).all(|i| n%i != 0)",
            "}",
        ],
        "description": "素数判定"
    },
    "sieve": {
        "scope": "rust",
        "prefix": "sieve",
        "body": [
            "fn sieve(n:usize) -> Vec<usize>{",
            "    let mut is_prime = vec![true;n+1];",
            "    is_prime[0] = false;",
            "    is_prime[1] = false;",
            "",
            "    let mut table = vec![];",
            "    for i in 2..=n{",
            "        if !is_prime[i] { continue }",
            "        table.push(i);",
            "        for j in (i*2..=n).step_by(i){",
            "            is_prime[j] = false;",
            "        }",
            "    }",
            "    return table",
            "}",
        ],
        "description": "エラトステネスの篩"
    },
    "pow_mod": {
        "scope": "rust",
        "prefix": "modpow",
        "body": [
            "fn modpow(n:usize, m:usize, _mod:usize) -> usize {",
            "    if m == 0 { return 1 }",
            "    let mut res = modpow(n*n%_mod, m/2, _mod);",
            "    if m%2 == 1{",
            "        res = &res*n%_mod;",
            "    }",
            "    return res",
            "}",
        ],
        "description": "高速べき乗計算"
    },
    "euler_phi": {
        "scope": "python",
        "prefix": "euler_phi",
        "body": [
            "def euler_phi(n):",
            "    res = n",
            "    x = 2",
            "    while x*x <= n:",
            "        if n % x == 0:",
            "            res = res // x * (x-1)",
            "            while n % x == 0:",
            "                n //= x",
            "        x += 1",
            "    if n > 1:",
            "        res = res // n * (n-1)",
            "    return res",
            "",
            "# calculate φ(x) for 1 <= x <= M",
            "M = 10**6",
            "*phi, = range(M+1)",
            "for x in range(2, M+1):",
            "    if phi[x] == x:",
            "        for y in range(x, M+1, x):",
            "            phi[y] = phi[y] // x * (x-1)",
        ],
        "description": "オイラーのファイ関数"
    },
    "Modint": {
        "scope": "pytho",
        "prefix": "Modint",
        "body": [
            "class ModInt:",
            "    def __init__(self, x):",
            "        self.x = x % MOD",
            "",
            "    def __str__(self):",
            "        return str(self.x)",
            "",
            "    __repr__ = __str__",
            "",
            "    def __add__(self, other):",
            "        return (",
            "            ModInt(self.x + other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x + other)",
            "        )",
            "",
            "    def __sub__(self, other):",
            "        return (",
            "            ModInt(self.x - other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x - other)",
            "        )",
            "",
            "    def __mul__(self, other):",
            "        return (",
            "            ModInt(self.x * other.x) if isinstance(other, ModInt) else",
            "            ModInt(self.x * other)",
            "        )",
            "",
            "    def __truediv__(self, other):",
            "        return (",
            "            ModInt(",
            "                self.x * pow(other.x, MOD - 2, MOD)",
            "            ) if isinstance(other, ModInt) else",
            "            ModInt(self.x * pow(other, MOD - 2, MOD))",
            "        )",
            "",
            "    def __pow__(self, other):",
            "        return (",
            "            ModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt) else",
            "            ModInt(pow(self.x, other, MOD))",
            "        )",
            "",
            "    __radd__ = __add__",
            "",
            "    def __rsub__(self, other):",
            "        return (",
            "            ModInt(other.x - self.x) if isinstance(other, ModInt) else",
            "            ModInt(other - self.x)",
            "        )",
            "",
            "    __rmul__ = __mul__",
            "",
            "    def __rtruediv__(self, other):",
            "        return (",
            "            ModInt(",
            "                other.x * pow(self.x, MOD - 2, MOD)",
            "            ) if isinstance(other, ModInt) else",
            "            ModInt(other * pow(self.x, MOD - 2, MOD))",
            "        )",
            "",
            "    def __rpow__(self, other):",
            "        return (",
            "            ModInt(pow(other.x, self.x, MOD)) if isinstance(other, ModInt) else",
            "            ModInt(pow(other, self.x, MOD))",
            "        )",
            "",
            "#除算",
            "A, B = map(ModInt, (map(int, input().split())))",
            "print(A / B)",
            "",
            "#通常のintとの演算",
            "A = ModInt(int(input()))",
            "print((1 + A)**3)",
            "",
            "#SUM関数",
            "N = int(input())",
            "print(sum(ModInt(i)**2 for i in range(1, N + 1)))",
        ],
        "description": "Modint"
    },
    "GrayCode": {
        "scope": "python",
        "prefix": "GrayCode",
        "body": [
            "def BinaryToGray(self, n):",
            "    return n^(n>>1)",
            "",
            "def grayToBinary(n):",
            "    res = 0",
            "    while n:",
            "        res ^= n",
            "        n>>=1",
            "    return res",
        ],
        "description": "Grayコード⇔Binaryコード変換"
    },
    "bit_search": {
        "scope": "rust",
        "prefix": "bit_search",
        "body": [
            "for bit in 0..(1<<N){",
            "",
            "    let mut su = 0;",
            "",
            "    for i in 0..N{",
            "        if bit & (1<<i) == 1 {",
            "            //ビットが立っているインデックスに対して何かする。",
            "        }",
            "    }",
            "}",
        ],
        "description": "ビット全探索"
    },
    "permutationCoeff(nPr)": {
        "scope": "rust",
        "prefix": "permutationCoeff(nPr)",
        "body": [
            "fn nPr(n:usize, r:usize) -> usize{",
            "    let mut fact = vec![];",
            "    fact.push(1);",
            "",
            "    for i in 1..=n{",
            "        fact.push(i*fact[i-1]);",
            "    }",
            "    return fact[n] / fact[n-r];",
            "}",
        ],
        "description": "順列(nPr)"
    },
    "permutation": {
        "scope": "rust",
        "prefix": "permutation",
        "body": [
            "for perm in (0..10).permutations(10){",
            "    println!(\"{:?}\",perm);",
            "}",
        ],
        "description": "順列全探索"
    },
    "permutation_product": {
        "scope": "python",
        "prefix": "permutation_product",
        "body": [
            "import itertools",
            "",
            "for prod in itertools.product($1, repeat=3)",
        ],
        "description": "順列全探索(重複あり) 直積(デカルト積)"
    },
    "combination": {
        "scope": "rust",
        "prefix": "combination",
        "body": [
            "for cmb in (0..10).combinations(3){",
            "    println!(\"{:?}\",cmb);",
            "}",
        ],
        "description": "組合せ全探索"
    },
    "combinations_with_replacement": {
        "scope": "rust",
        "prefix": "combinations_with_replacement",
        "body": [
            "for cmb in (0..10).combinations_with_replacement(3){",
            "    println!(\"{:?}\",cmb);",
            "}",
        ],
        "description": "組合せ全探索(重複あり)"
    },
    "binomialCoeff(nCr)": {
        "scope": "rust",
        "prefix": "binomialCoeff(nCr)",
        "body": [
            "fn nCr(n:usize, r:usize) -> usize{",
            "    let mut res = 1;",
            "    for i in 0..r{",
            "        res = (res*(n-i))/(i+1);",
            "    }",
            "    return res",
            "}",
        ],
        "description": "組み合わせの通り数(nCr)"
    },
    "combination_with_repetition(nHr)": {
        "scope": "rust",
        "prefix": "combination_with_repetition(nHr)",
        "body": [
            "fn nHr(n:usize, r:usize) -> usize {",
            "    let mut res = 1;",
            "    for i in 0..r{",
            "        res = (res*(n+r-1-i))/(i+1);",
            "    }",
            "    return res",
            "}",
        ],
        "description": "組み合わせ(重複あり)の通り数(nHr)"
    },
    "binomialCoeff(nCr_mod)": {
        "scope": "rust",
        "prefix": "binomialCoeff(nCr_mod)",
        "body": [
            "const MOD: usize = 1_000_000_007;",
            "fn modpow(n:usize, m:usize, _mod:usize) -> usize {",
            "    if m == 0 { return 1 }",
            "    let mut res = modpow(n*n%_mod, m/2, _mod);",
            "    if m%2 == 1{",
            "        res = &res*n%_mod;",
            "    }",
            "    return res",
            "}",
            "",
            "fn nCr(n:usize, r:usize) -> usize{",
            "    let mut numera = 1; // 分子",
            "    let mut denomi = 1; // 分母",
            "",
            "    for i in 0..r{",
            "        numera = (numera*(n-i))%MOD;",
            "        denomi = (denomi*(i+1))%MOD;",
            "    }",
            "    return numera * modpow(denomi, MOD-2, MOD) % MOD;",
            "}",
        ],
        "description": "組み合わせの通り数(nCr)をmodで割った余り"
    },
    "crt": {
        "scope": "python",
        "prefix": "crt",
        "body": [
            "def inv_gcd(a,b):",
            "    a=a%b",
            "    if a==0:",
            "        return (b,0)",
            "    s=b;t=a",
            "    m0=0;m1=1",
            "    while(t):",
            "        u=s//t",
            "        s-=t*u",
            "        m0-=m1*u",
            "        s,t=t,s",
            "        m0,m1=m1,m0",
            "    if m0<0:",
            "        m0+=b//s",
            "    return (s,m0)",
            "",
            "def inv_mod(x,m):",
            "    assert 1<=m",
            "    z=inv_gcd(x,m)",
            "    assert z[0]==1",
            "    return z[1]",
            "",
            "def crt(r,m):",
            "    assert len(r)==len(m)",
            "    n=len(r)",
            "    r0=0;m0=1",
            "    for i in range(n):",
            "        assert 1<=m[i]",
            "        r1=r[i]%m[i]",
            "        m1=m[i]",
            "        if m0<m1:",
            "            r0,r1=r1,r0",
            "            m0,m1=m1,m0",
            "        if (m0%m1==0):",
            "            if (r0%m1!=r1):",
            "                return (0,0)",
            "            continue",
            "        g,im=inv_gcd(m0,m1)",
            "        u1=m1//g",
            "        if ((r1-r0)%g):",
            "            return (0,0)",
            "        x=(r1-r0)//g % u1*im%u1",
            "        r0+=x*m0",
            "        m0*=u1",
            "        if r0<0:",
            "            r0+=m0",
            "    return (r0,m0)",
            " ",
            "T=int(input())",
            "for _ in range(T):",
            "    X,Y,P,Q = map(int, input().split())",
            "    ans = 10**30",
            "    for y in range(Y):",
            "        for q in range(Q):",
            "            C = [2*(X+Y),P+Q]#これで割ったら",
            "            R = [X+y,P+q]#この余りになる対のリスト",
            "            r,m = crt(R,C)",
            "            if m!=0:",
            "                ans = min(ans,r)",
            "    if ans==10**30:",
            "        print('infinity')",
            "    else:",
            "        print(ans)",
        ],
        "description": "中国剰余定理(○で割ったら△になる数字を見つける)"
    },
    "floor_sum": {
        "scope": "python",
        "prefix": "floor_sum",
        "body": [
            "# [0,n)の範囲で、y=a/m*x+b/mの下側(直線上含む)にある格子点の数を求める",
            "def floor_sum(n,m,a,b):",
            "    ans=0",
            "    if a>=m:",
            "        ans+=(n-1)*n*(a//m)//2",
            "        a%=m",
            "    if b>=m:",
            "        ans+=n*(b//m)",
            "        b%=m",
            "    y_max=(a*n+b)//m",
            "    x_max=(y_max*m-b)",
            "    if y_max==0:",
            "        return ans",
            "    ans+=(n-(x_max+a-1)//a)*y_max",
            "    ans+=floor_sum(y_max,a,m,(a-x_max%a)%a)",
            "    return ans",
        ],
        "description": "floor_sum"
    },
    "LIS": {
        "scope": "rust",
        "prefix": "LIS",
        "body": [
            "let mut L = vec![]; // L[x]:長さx+1の部分列の最後の要素として考えられる最小値",
            "let mut ans = 0;",
            "for i in 0..N{",
            "    let pos = L.lower_bound(&(A[i]));",
            "    // let pos = L.upper_bound(&(A[i])); // 広義単調増加",
            "",
            "    if pos == ans{",
            "        L.push(A[i]);",
            "        ans += 1;",
            "    }else{",
            "        L[pos] = A[i];",
            "    }",
            "}",
        ],
        "description": "最長増加部分列（LIS）"
    },
    "rotation_matrix": {
        "scope": "python",
        "prefix": "rotation_matrix",
        "body": [
            "import math",
            "#回転前の座標",
            "x = ",
            "y = ",
            "#回転中心の座標(原点の場合は0)",
            "center_x = ",
            "center_y = ",
            "#回転角度(radian)",
            "angle = math.pi*2",
            "#回転後の座標 ",
            "X = math.cos(angle) * (x - center_x) - math.sin(angle) * (y - center_y) + center_x",
            "Y = math.sin(angle) * (x - center_x) + math.cos(angle) * (y - center_y) + center_y",
        ],
        "description": "回転行列"
    },
    "compress_position": {
        "scope": "rust",
        "prefix": "compress_position",
        "body": [
            "    let mut cp = A.clone();",
            "    cp.sort();",
            "    cp.dedup();",
            "",
            "    let mut A_compress = vec![];",
            "    for a in A{",
            "        A_compress.push(cp.binary_search(&a).unwrap()+1);",
            "    }",
        ],
        "description": "座標圧縮"
    },
    "compress_position_2d": {
        "scope": "python",
        "prefix": "compress_position_2d",
        "body": [
            "def compress(arr):",
            "    return {e: i for i, e in enumerate(arr)}",
            "",
            "N = int(input())",
            "rect = []",
            "vals_x, vals_y = set(), set()",
            "for _ in range(N):",
            "    X1,Y1,X2,Y2 = map(int,input().split())",
            "    rect.append([X1,Y1,X2,Y2])",
            "    vals_x |= {X1,X2}",
            "    vals_y |= {Y1,Y2}",
            "vals_x2, vals_y2 = sorted(vals_x), sorted(vals_y)",
            "comp_x, comp_y = compress(vals_x2), compress(vals_y2)",
            "",
            "H,W = len(comp_y), len(comp_x)",
            "A = [[0]*(W+1) for _ in range(H+1)]",
            "for x1,y1,x2,y2 in rect:",
            "    lx,ly,rx,ry = comp_x[x1],comp_y[y1],comp_x[x2],comp_y[y2]",
            "    A[ly][lx] += 1",
            "    A[ry][rx] += 1",
            "    A[ry][lx] -= 1",
            "    A[ly][rx] -= 1",
            "",
            "for y in range(H):",
            "    for x in range(1,W):",
            "        A[y][x] += A[y][x-1]",
            "",
            "for y in range(1,H):",
            "    for x in range(W):",
            "        A[y][x] += A[y-1][x]",
            "",
            "ans = 0",
            "for y in range(H):",
            "    for x in range(W):",
            "        if A[y][x]:",
            "            ans += (vals_x2[x+1] - vals_x2[x]) * (vals_y2[y+1] - vals_y2[y])",
            "",
            "print(ans)",
            "",
        ],
        "description": "二次元座標圧縮"
    },
    "counter": {
        "scope": "rust",
        "prefix": "counter",
        "body": [
            "let mut count = HashMap::new();",
            "for c in &S {",
            "    *count.entry(c).or_insert(0) += 1;",
            "}",
        ],
        "description": "ベクタ内の要素の数え上げ"
    },
    "defaultdict": {
        "scope": "python",
        "prefix": "defaultdict",
        "body": [
            "from collections import defaultdict",
            "dic = defaultdict(int)",
        ],
        "description": "defaultdict"
    },
    "alphabet": {
        "scope": "python",
        "prefix": "alphabet",
        "body": [
            "alphabet = dict.fromkeys(\"abcdefghijklmnopqrstuvwxyz\",0)",
        ],
        "description": "アルファベットの辞書"
    },
    "chr_and_ord": {
        "scope": "python",
        "prefix": "chr_and_ord",
        "body": [
            "# 0-indexed",
            "def int_to_lower(k):",
            "    return chr(k+97)",
            "",
            "def int_to_upper(k):",
            "    return chr(k+65)",
            "",
            "def lower_to_int(c):",
            "    return ord(c)-97",
            "",
            "def upper_to_int(c):",
            "    return ord(c)-65",
        ],
        "description": "k番目のアルファベットcを相互変換"
    },
    "rotate_string": {
        "scope": "rust",
        "prefix": "rotate_string",
        "body": [
            "    let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];",
            "    a.rotate_left(2); // ['c', 'd', 'e', 'f', 'a', 'b']",
            "    a.rotate_right(2); // ['e', 'f', 'a', 'b', 'c', 'd']",
            "",
        ],
        "description": "文字列sをn文字分左/右に回転"
    },
    "regular_expression": {
        "scope": "python",
        "prefix": "regular_expression",
        "body": [
            "import re",
            "s = \"testtestest\"",
            "p = re.compile('test')",
            "hit = p.match(s)",
            "find = p.findall(s) # ['test', 'test']",
        ],
        "description": "正規表現"
    },
    "LCS": {
        "scope": "rust",
        "prefix": "LCS",
        "body": [
            "    let (LS,LT) = (S.len(),T.len());",
            "    let mut dp = vec![vec![0;LT+1];LS+1];",
            "",
            "    // LCS(最長共通部分列)をDPで求める",
            "    for i in 0..LS{",
            "        for j in 0..LT{",
            "            if S[i] == T[j]{",
            "                dp[i+1][j+1] = max(max(dp[i][j+1], dp[i+1][j]), dp[i][j]+1);",
            "            }else{",
            "                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);",
            "            }",
            "        }",
            "    }",
            "",
            "    // 復元処理",
            "    let mut res:Vec<char> = vec![];",
            "    let (mut i, mut j) = (LS,LT);",
            "    while i > 0 && j > 0{",
            "        if S[i-1] == T[j-1]{",
            "            res.push(S[i-1]);",
            "            i -= 1;",
            "            j -= 1;",
            "        }else if dp[i][j] == dp[i-1][j]{",
            "            i -= 1;",
            "        }else if dp[i][j] == dp[i][j-1]{",
            "            j -= 1;",
            "        }",
            "    }",
            "    res.reverse();",
            "    let res = res.iter().join(\"\");",
        ],
        "description": "LCS(最長共通部分列)"
    },
    "LCS_COUNT": {
        "scope": "python",
        "prefix": "LCS_COUNT",
        "body": [
            "def lcs_count(S, T):",
            "    L1 = len(S)",
            "    L2 = len(T)",
            "    dp = [[0]*(L2+2) for i in range(L1+2)]",
            "    sdp = [[0]*(L2+2) for i in range(L1+2)]",
            "    dp[0][0] = 1",
            "    sdp[1][1] = 1",
            " ",
            "    for i in range(L1+1):",
            "        for j in range(L2+1):",
            "            if i == 0 and j == 0:",
            "                continue",
            "            if i-1 >= 0 and j-1 >= 0 and S[i-1] == T[j-1]:",
            "                dp[i][j] = sdp[i][j]",
            "            sdp[i+1][j+1] = (sdp[i+1][j] + sdp[i][j+1] - sdp[i][j] + dp[i][j]) % (10**9+7)",
            "",
            "    # sdp[L1+1][L2+1] が部分文字列の個数",
            "    return sdp[L1+1][L2+1]",
        ],
        "description": "CS(共通部分列)の個数カウント"
    },
    "Levenshtein_distance": {
        "prefix": "Levenshtein_distance",
        "body": [
            "    let (LS,LT) = (S.len(),T.len());",
            "    let mut dp = vec![vec![INF;LT+1];LS+1];",
            "    for i in 0..=LS{ dp[i][0] = i}",
            "    for j in 0..=LT{ dp[0][j] = j}",
            "",
            "    // 編集距離(レーベンシュタイン距離)をDPで求める",
            "    for i in 0..LS{",
            "        for j in 0..LT{",
            "            dp[i+1][j+1] = min(min(dp[i][j+1]+1, dp[i+1][j]+1), dp[i][j] + if S[i] == T[j] {0} else {1});",
            "        }",
            "    }",
            "",
            "    println!(\"{}\",dp[LS][LT]);",
        ],
        "description": "編集距離(レーベンシュタイン距離)"
    },
    "RollingHash": {
        "scope": "rust",
        "prefix": "RollingHash",
        "body": [
            "use rand::Rng;",
            "// 拝借元：https://github.com/kenkoooo/competitive-programming-rs/blob/master/src/string/rolling_hash.rs",
            "pub mod rolling_hash {",
            "    const MASK_30: u64 = (1 << 30) - 1;",
            "    const MASK_31: u64 = (1 << 31) - 1;",
            "    const MOD: u64 = (1 << 61) - 1;",
            "",
            "    pub struct RollingHash {",
            "        hash: Vec<u64>,",
            "        pow: Vec<u64>,",
            "    }",
            "",
            "    impl RollingHash {",
            "        pub fn new(s: &[u8], base: u64) -> RollingHash {",
            "            let n = s.len();",
            "            let mut hash: Vec<u64> = vec![0; n + 1];",
            "            let mut pow: Vec<u64> = vec![0; n + 1];",
            "            pow[0] = 1;",
            "            for i in 0..n {",
            "                pow[i + 1] = modulo(mod_mul(pow[i], base));",
            "                hash[i + 1] = modulo(mod_mul(hash[i], base) + s[i] as u64);",
            "            }",
            "            RollingHash { hash, pow }",
            "        }",
            "",
            "        /// Get hash of [l, r)",
            "        pub fn get_hash(&self, l: usize, r: usize) -> u64 {",
            "            modulo(self.hash[r] + MOD - mod_mul(self.hash[l], self.pow[r - l]))",
            "        }",
            "    }",
            "",
            "    fn mod_mul(a: u64, b: u64) -> u64 {",
            "        let (a_prefix, a_suffix) = (a >> 31, a & MASK_31);",
            "        let (b_prefix, b_suffix) = (b >> 31, b & MASK_31);",
            "        let m = a_suffix * b_prefix + a_prefix * b_suffix;",
            "        modulo(a_prefix * b_prefix * 2 + (m >> 30) + ((m & MASK_30) << 31) + a_suffix * b_suffix)",
            "    }",
            "",
            "    fn modulo(v: u64) -> u64 {",
            "        let v = (v & MOD) + (v >> 61);",
            "        if v >= MOD {",
            "            v - MOD",
            "        } else {",
            "            v",
            "        }",
            "    }",
            "}",
            "",
            "// 以下はmain()内に記述",
            "let mut rng = rand::thread_rng();",
            "let BASE = rng.gen_range(2,(1<<61)-1);",
            "let rh = rolling_hash::RollingHash::new(&S.as_bytes(),BASE);",
        ],
        "description": "ローリングハッシュ"
    },
    "Dijkstra": {
        "scope": "rust",
        "prefix": "Dijkstra",
        "body": [
            "input! {",
            "    N: usize,",
            "    M: usize,",
            "    edges: [(Usize1, Usize1, usize); M]",
            "}",
            "",
            "let mut graph = vec![vec![];N];",
            "for &(A,B,C) in &edges{",
            "    graph[A].push((B,C));",
            "    graph[B].push((A,C)); // 有向グラフの場合はコメントアウトする。",
            "}",
            "",
            "// ダイクストラ法での最短経路算出(計算量はO((E+V)logV))",
            "let mut dist = vec![INF;N];",
            "let mut prev = vec![INF;N];",
            "fn dijkstra(n:usize, graph:&Vec<Vec<(usize,usize)>>, s:usize, dist:&mut Vec<usize>, prev:&mut Vec<usize>) {",
            "    let mut heap = BinaryHeap::new();",
            "    heap.push((Reverse(0),s));",
            "    dist[s] = 0;",
            "    while !heap.is_empty() {",
            "        let (Reverse(cost),v) = heap.pop().unwrap();",
            "        if dist[v] < cost{ continue }",
            "        for &(to, cost) in &graph[v] {",
            "            if dist[v] + cost < dist[to] {",
            "                dist[to] = dist[v] + cost;",
            "                heap.push((Reverse(dist[to]), to));",
            "                prev[to] = v;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "// 最短経路復元",
            "fn get_path(mut t: usize, dist:&Vec<usize>, prev:&Vec<usize>) -> Vec<usize> {",
            "    let mut path = vec![];",
            "    if dist[t] == INF { return path }",
            "    while t != INF {",
            "        path.push(t);",
            "        t = prev[t];",
            "    }",
            "    path.reverse();",
            "    return path",
            "}",
            "",
            "dijkstra(N, &graph, 0, &mut dist, &mut prev);",
        ],
        "description": "ダイクストラ法：2点間の最短路をO(ElogV)で求める(負経路はNG)"
    },
    "Bellman_Ford": {
        "scope": "python",
        "prefix": "Bellman_Ford",
        "body": [
            "inf=float(\"inf\")",
            "def bellman_ford(s,n):",
            "    dist = [inf] * n",
            "    dist[s]=0",
            "    for i in range(n):",
            "        for edge in edges:",
            "            if dist[edge[1]] > dist[edge[0]] + edge[2]:",
            "                dist[edge[1]] = dist[edge[0]] + edge[2]",
            "                if i==n-1: return -1",
            "    return dist",
            "",
            "v,e,r = map(int, input().split())",
            "edges = []",
            "for i in range(e):",
            "    s, t, d = map(int, input().split())",
            "    edges.append((s, t, d))",
            "",
            "dist = bellman_ford(r,v)",
        ],
        "description": "ベルマンフォード法：２点間の最短路をO(EV)で見つける(負経路もOK)"
    },
    "Warshall_Floyd": {
        "scope": "python",
        "prefix": "Warshall_Floyd",
        "body": [
            "#d[i][j]は2頂点間i, j間の移動コストを格納, Vは頂点数",
            "INF = 10**18",
            "def Warshall_Floyd(d,nxt,n):",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                if d[i][k]!=INF and d[k][j]!=INF:",
            "                    if d[i][k] + d[k][j] < d[i][j]:",
            "                        d[i][j] = d[i][k] + d[k][j]",
            "                        nxt[i][j] = nxt[i][k]",
            "                    elif k != i and d[i][k] + d[k][j] == d[i][j]:",
            "                        nxt[i][j] = min(nxt[i][j], nxt[i][k]) #辞書順最小化",
            "",
            "#s→tの最短経路復元",
            "def get_path(s,t):",
            "    if dist[s][t] == INF:",
            "        return []",
            "    path = [s]",
            "    curr = s",
            "    while curr != t:",
            "        curr = nxt[curr][t]",
            "        path.append(curr)",
            "    return path",
            "",
            "#隣接行列で経路を格納",
            "N,M = map(int, input().split())",
            "dist = [[INF]*N for _ in range(N)]",
            "for i in range(M):",
            "    s,t,d = map(int, input().split())",
            "    s,t = s-1,t-1",
            "    dist[s][t] = d",
            "",
            "#s,tが同じ場合は距離0",
            "for i in range(N):",
            "    dist[i][i] = 0",
            "",
            "#経路復元用",
            "nxt = [[0]*N for _ in range(N)]",
            "for i in range(N):",
            "    for j in range(N):",
            "        nxt[i][j] = j",
            "",
            "Warshall_Floyd(dist,nxt,N)",
            "",
            "#負経路の有無チェック",
            "for i in range(N):",
            "    if dist[i][i] < 0:",
            "        print(\"NEGATIVE CYCLE\")",
            "        exit()",
            "",
            "#全点対間距離の出力",
            "for i in range(N):",
            "    for j in range(N):",
            "        if dist[i][j] == INF:",
            "            dist[i][j] = \"INF\"",
            "    print(*dist[i])",
            "",
        ],
        "description": "ワーシャルフロイド法：グラフの全ての頂点の間の最短路をO(V^3)で見つける(負経路もOK)"
    },
    "Union-Find": {
        "scope": "python",
        "prefix": "Union-Find",
        "body": [
            "from collections import defaultdict",
            "",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1]*n",
            "",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        self.parents[x] = self.find(self.parents[x])",
            "        return self.parents[x]",
            "",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "",
            "        if x == y:",
            "            return",
            "",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "",
            "    def group_count(self):",
            "        return len(self.roots())",
            "",
            "    def all_group_members(self):",
            "        group_members = defaultdict(list)",
            "        for member in range(self.n):",
            "            group_members[self.find(member)].append(member)",
            "        return group_members",
            "",
            "    def __str__(self):",
            "        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())",
            "'''",
            "uf = UnionFind(N) -> create 6 separated nodes",
            "uf.union(0, 2) -> unite two ids",
            "uf.same(0, 2) -> have same top node?",
            "uf.find(0) -> id of top node",
            "uf.size(5) -> num of group",
            "",
            "# 文字列や任意の数字を要素にしたり復元したい場合",
            "l = ['A', 'B', 'C', 'D', 'E']",
            "",
            "# {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}",
            "d = {x: i for i, x in enumerate(l)}",
            "",
            "# {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E'}",
            "d_inv = {i: x for i, x in enumerate(l)}",
            "",
            "uf.union(d['A'], d['D'])",
            "print(d_inv[uf.find(d['D'])])",
            "# A",
            "'''",
        ],
        "description": "Union-Find"
    },
    "WeightedUnion-Find": {
        "scope": "python",
        "prefix": "WeightedUnion-Find",
        "body": [
            "# 重み付きUnionFind",
            "class WeightedUnionFind:",
            "    def __init__(self, n):",
            "        self.parents = [i for i in range(n)] # 親",
            "        self.rank = [0]*n # 木の深さ",
            "        self.weights = [0]*n # 重み",
            "",
            "    # xの根を探索",
            "    def find(self, x):",
            "        if self.parents[x] == x:",
            "            return x",
            "        root = self.find(self.parents[x])",
            "        self.weights[x] += self.weights[self.parents[x]]",
            "        self.parents[x] = root",
            "        return root",
            "",
            "    # xからyへの重みをweightとして統合",
            "    def union(self, x, y, weight=0):",
            "        root_x, root_y = self.find(x), self.find(y)",
            "        if root_x == root_y:",
            "            return",
            "        if self.rank[root_x] < self.rank[root_y]:",
            "            self.parents[root_x] = root_y",
            "            self.weights[root_x] = weight - self.weights[x] + self.weights[y]",
            "        else:",
            "            self.parents[root_y] = root_x",
            "            self.weights[root_y] = -weight - self.weights[y] + self.weights[x]",
            "            if self.rank[root_x] == self.rank[root_y]:",
            "                self.rank[root_x] += 1",
            "",
            "    # xとyが同じグループか",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "    # xからyへのコスト",
            "    def diff(self, x, y):",
            "        return self.weights[x] - self.weights[y]",
            "",
            "'''",
            "wuf = WeightedUnionFind(N) -> create N separated nodes",
            "wuf.union(0, 2, 5) -> unite two ids with weight=5 from 0 to 2",
            "wuf.same(0, 2) -> have same top node?",
            "wuf.find(0) -> id of top node",
            "",
            "# 文字列や任意の数字を要素にしたり復元したい場合",
            "l = ['A', 'B', 'C', 'D', 'E']",
            "",
            "# {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}",
            "d = {x: i for i, x in enumerate(l)}",
            "",
            "# {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E'}",
            "d_inv = {i: x for i, x in enumerate(l)}",
            "",
            "wuf.union(d['A'], d['D'], weight)",
            "print(d_inv[uf.find(d['D'])])",
            "# A",
            "'''",
        ],
        "description": "重み付きUnion-Find"
    },
    "Kruskal": {
        "scope": "rust",
        "prefix": "Kruskal",
        "body": [
            "input! {",
            "    N: usize,",
            "    M: usize,",
            "    mut edges: [(Usize1, Usize1, usize); M]",
            "}",
            "",
            "// クラスカル法",
            "// edges: 辺集合[始点, 終点, 重み]",
            "edges.sort_by_key(|&x| x.2);",
            "let mut weight = 0;",
            "let mut nodes = BTreeSet::<usize>::new();",
            "let mut uf = UnionFind::<usize>::new(N);",
            "for &(s,t,w) in &edges{",
            "    if !uf.equiv(s,t){",
            "        uf.union(s,t);",
            "        weight += w;",
            "        nodes.insert(s);",
            "        nodes.insert(t);",
            "    }",
            "}",
            "",
            "println!(\"{}\",weight);",
            "println!(\"{}\",nodes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(\" \"));",
            "",
        ],
        "description": "最小全域木の辺の重みの総和の算出"
    },
    "Chu_Liu_Edmonds": {
        "scope": "python",
        "prefix": "Chu_Liu_Edmonds",
        "body": [
            "from heapq import heappush, heappop",
            "def chu_liu_edmonds(v,edges,r):",
            "    if v <= 1:",
            "        return 0",
            "    q = [[] for _ in range(0, v)]",
            "    for s, t, w in edges:",
            "        heappush(q[t], (w, s))",
            "    M = [(0, -1) for _ in range(0, v)]",
            "    for t in range(0, v):",
            "        if t != r:",
            "            w, s = heappop(q[t])",
            "            M[t] = (w, s)",
            "    ",
            "    used = [False for _ in range(0, v)]",
            "    hist = []",
            "    cycle = []",
            "    for t in range(0, v):",
            "        w, s = M[t]",
            "        if s == -1 or used[t] == True:",
            "            continue",
            "        if used[t] == False:",
            "            used[t] = True",
            "            hist += [t]",
            "            tt = s",
            "            while used[tt] == False:",
            "                used[tt] = True",
            "                hist += [tt]",
            "                w, s = M[tt]",
            "                if s == -1:",
            "                    hist = []",
            "                    break",
            "                tt = s",
            "            if used[tt] == True and s != -1 and 0 < len(hist):",
            "                try:",
            "                    k = hist.index(tt)",
            "                    cycle = hist[k:]",
            "                except:",
            "                    continue",
            "                finally:",
            "                    pass",
            "                break",
            "                ",
            "    if len(cycle) == 0:",
            "        return sum(m[0] for m in M)",
            "",
            "    parent = min(cycle)",
            "    rn = [0 for _ in range(0, v)]",
            "    k = 0",
            "    for t in range(0, v):",
            "        if k == parent:",
            "            k += 1",
            "        if t in cycle:",
            "            rn[t] = parent",
            "        else:",
            "            rn[t] = k",
            "            k += 1",
            "            ",
            "    Vp = v - len(cycle) + 1",
            "    Ep = []",
            "    for s, t, w in edges:",
            "        if s in cycle:",
            "            if t in cycle:",
            "                continue",
            "            else:",
            "                Ep += [[parent, rn[t], w]]",
            "        else:",
            "            if t in cycle:",
            "                Ep += [[rn[s], parent, w - M[t][0]]]",
            "            else:",
            "                Ep += [[rn[s], rn[t], w]]",
            "    r = rn[r]",
            "    return chu_liu_edmonds(Vp, Ep, r) + sum(M[t][0] for t in cycle)",
            "",
            "v,e,r = map(int, input().split())",
            "edges = []",
            "for _ in range(e):",
            "    s, t, w = map(int, input().split())",
            "    edges.append((s, t, w))",
            "",
            "print(chu_liu_edmonds(v, edges, r))",
        ],
        "description": "#最小全域有向木の辺の重みの総和を求める"
    },
    "tree_diameter": {
        "scope": "python",
        "prefix": "tree_diameter",
        "body": [
            "# N: 木Tの頂点数",
            "# G[u] = [(w, c), ...]:",
            "#   頂点uに隣接する頂点wとそれを繋ぐ辺の長さc",
            "from collections import deque",
            "def tree_diameter(s):",
            "    dist = [None]*N",
            "    que = deque([s])",
            "    dist[s] = 0",
            "    while que:",
            "        v = que.popleft()",
            "        d = dist[v]",
            "        for w, c in G[v]:",
            "            if dist[w] is not None:",
            "                continue",
            "            dist[w] = d + c",
            "            que.append(w)",
            "    d = max(dist)",
            "    return dist.index(d), d",
            "",
            "u, _ = tree_diameter(0)",
            "v, d = tree_diameter(u)",
            "# パスu-vがこの木Tの直径(長さd)",
        ],
        "description": "木の直径"
    },
    "LCA": {
        "scope": "python",
        "prefix": "LCA",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "class LCA:",
            "    \"\"\"",
            "    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み)",
            "    というグラフ情報から、ダブリングによるLCAを構築。",
            "    任意の2頂点のLCAおよび距離を取得できるようにする",
            "    \"\"\"",
            " ",
            "    def __init__(self, n, links, root=0):",
            "        self.depths = [-1] * n",
            "        self.distances = [-1] * n",
            "        prev_ancestors = self._init_dfs(n, links, root)",
            "        self.ancestors = [prev_ancestors]",
            "        max_depth = max(self.depths)",
            "        d = 1",
            "        while d < max_depth:",
            "            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]",
            "            self.ancestors.append(next_ancestors)",
            "            d <<= 1",
            "            prev_ancestors = next_ancestors",
            " ",
            "    def _init_dfs(self, n, links, root):",
            "        q = [(root, -1, 0, 0)]",
            "        direct_ancestors = [-1] * (n + 1)  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1",
            "        while q:",
            "            v, p, dep, dist = q.pop()",
            "            direct_ancestors[v] = p",
            "            self.depths[v] = dep",
            "            self.distances[v] = dist",
            "            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)",
            "        return direct_ancestors",
            " ",
            "    def get_lca(self, u, v):",
            "        du, dv = self.depths[u], self.depths[v]",
            "        if du > dv:",
            "            u, v = v, u",
            "            du, dv = dv, du",
            "        tu = u",
            "        tv = self.upstream(v, dv - du)",
            "        if u == tv:",
            "            return u",
            "        for k in range(du.bit_length() - 1, -1, -1):",
            "            mu = self.ancestors[k][tu]",
            "            mv = self.ancestors[k][tv]",
            "            if mu != mv:",
            "                tu = mu",
            "                tv = mv",
            "        lca = self.ancestors[0][tu]",
            "        assert lca == self.ancestors[0][tv]",
            "        return lca",
            " ",
            "    def get_distance(self, u, v):",
            "        lca = self.get_lca(u, v)",
            "        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]",
            " ",
            "    def upstream(self, v, k):",
            "        i = 0",
            "        while k:",
            "            if k & 1:",
            "                v = self.ancestors[i][v]",
            "            k >>= 1",
            "            i += 1",
            "        return v",
            "",
            "N = int(input())",
            "graph = [[] for _ in range(N)]",
            "for _ in range(N-1):",
            "    a,b =map(int,input().split())",
            "    a,b = a-1,b-1",
            "    graph[a].append((b,1))",
            "    graph[b].append((a,1))",
            "",
            "lca = LCA(N,graph)",
        ],
        "description": "LCA(最小共通祖先)"
    },
    "LowLink": {
        "scope": "python",
        "prefix": "LowLink",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def get_articulation_points(adj, n, start=0):",
            "    order = [None]*n",
            "    result = []; count = 0",
            "    def dfs(v, prev):",
            "        nonlocal count",
            "        r_min = order[v] = count # 到達時にラベル",
            "        fcnt = 0; p_art = 0",
            "        count += 1",
            "        for w in adj[v]:",
            "            if w == prev:",
            "                continue",
            "            if order[w] is None:",
            "                ret = dfs(w, v)",
            "                # 子の頂点が到達できたのが、自身のラベル以上の頂点のみ",
            "                # => 頂点vは関節点",
            "                p_art |= (order[v] <= ret)",
            "                r_min = min(r_min, ret)",
            "                fcnt += 1",
            "            else:",
            "                r_min = min(r_min, order[w])",
            "        p_art |= (r_min == order[v] and len(adj[v]) > 1)",
            "        if (prev == -1 and fcnt > 1) or (prev != -1 and p_art):",
            "            # 頂点startの場合は、二箇所以上の子頂点を調べたら自身は関節点",
            "            result.append(v)",
            "        return r_min",
            "    dfs(start, -1)",
            "    return result",
            "",
            "v,e = map(int, input().split())",
            "adj = [[] for i in range(v)]",
            "for _ in range(e):",
            "    s, t = map(int, input().split())",
            "    adj[s].append(t)",
            "    adj[t].append(s)",
            "    ",
            "ans = sorted(get_articulation_points(adj, v, start=0))",
        ],
        "description": "無向グラフの関節点(Articulation Points)の算出"
    },
    "Bridge": {
        "scope": "python",
        "prefix": "Bridge",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "def bridge(adj, n):",
            "    result = set()",
            "    label = [None]*n",
            "    gen = 0",
            "    cost = [0]*n",
            "    def dfs(u, p):",
            "        nonlocal gen",
            "        res = 0",
            "        for v in adj[u]:",
            "            if v == p:",
            "                continue",
            "            if label[v] is not None:",
            "                if label[v] < label[u]:",
            "                    cost[v] += 1",
            "                    res += 1",
            "            else:",
            "                label[v] = gen; gen += 1",
            "                r = dfs(v, u)",
            "                if r == 0:",
            "                    result.add((u, v) if u < v else (v, u))",
            "                res += r",
            "        res -= cost[u]",
            "        return res",
            "    for v in range(n):",
            "        if not label[v]:",
            "            label[v] = gen; gen += 1",
            "            r = dfs(v, -1)",
            "            assert r == 0, r",
            "    return result",
            "",
            "v,e = map(int, input().split())",
            "adj = [[] for i in range(v)]",
            "for _ in range(e):",
            "    s, t = map(int, input().split())",
            "    adj[s].append(t)",
            "    adj[t].append(s)",
            "    ",
            "ans = sorted(bridge(adj, v))",
        ],
        "description": "グラフの橋(除去するとグラフが連結でなくなる辺)を検出"
    },
    "SCC": {
        "scope": "python",
        "prefix": "SCC",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "# 強連結成分分解(SCC): グラフGに対するSCCを行う",
            "# 入力: <N>: 頂点サイズ, <G>: 順方向の有向グラフ, <RG>: 逆方向の有向グラフ",
            "# 出力: num_group:ラベル数, group:各頂点のラベル番号",
            "def scc(N, G, RG):",
            "    order = []",
            "    used = [0]*N",
            "    group = [None]*N",
            "    def dfs(s):",
            "        used[s] = 1",
            "        for t in G[s]:",
            "            if not used[t]:",
            "                dfs(t)",
            "        order.append(s)",
            "    def rdfs(s, col):",
            "        group[s] = col",
            "        used[s] = 1",
            "        for t in RG[s]:",
            "            if not used[t]:",
            "                rdfs(t, col)",
            "    for i in range(N):",
            "        if not used[i]:",
            "            dfs(i)",
            "    used = [0]*N",
            "    num_group = 0",
            "    for s in reversed(order):",
            "        if not used[s]:",
            "            rdfs(s, num_group)",
            "            num_group += 1",
            "    return num_group, group",
            "",
            "# 縮約後のグラフを構築",
            "def construct(N, G, label, group):",
            "    G0 = [set() for i in range(label)]",
            "    GP = [[] for i in range(label)]",
            "    for v in range(N):",
            "        lbs = group[v]",
            "        for w in G[v]:",
            "            lbt = group[w]",
            "            if lbs == lbt:",
            "                continue",
            "            G0[lbs].add(lbt)",
            "        GP[lbs].append(v)",
            "    return G0, GP",
            "",
            "N = int(input())",
            "X = list(map(int,input().split()))",
            "",
            "G = [[] for _ in range(N)]",
            "RG = [[] for _ in range(N)]",
            "for i in range(N):",
            "    X[i] -= 1",
            "    G[i].append(X[i])",
            "    RG[X[i]].append(i)",
            "",
            "num_group,group = scc(N,G,RG)",
            "G0,GP = construct(N,G,num_group,group)",
            "",
        ],
        "description": "SCC(強連結成分分解)"
    },
    "dfs_graph": {
        "scope": "rust",
        "prefix": "dfs_graph",
        "body": [
            "let mut seen = vec![false;N];",
            "fn dfs(s:usize, graph:&Vec<Vec<usize>>, seen:&mut Vec<bool>){",
            "    seen[s] = true;",
            "    for &to in &graph[s]{",
            "        if seen[to] == false{",
            "            dfs(to, graph, seen);",
            "        }",
            "    }",
            "}",
            "",
            "dfs(0,&graph,&mut seen);",
        ],
        "description": "DFS(グラフ)"
    },
    "dfs_timestamp": {
        "scope": "python",
        "prefix": "dfs_timestamp",
        "body": [
            "# Pythonで提出!!",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "# 連結でないグラフの場合は、未発見の頂点が無くなるまでdfsを繰り返す必要あり",
            "# コメントアウト箇所を有効化するとオイラーツアー可能",
            "def dfs(s):",
            "    global cnt",
            "",
            "    # 行きがけ",
            "    cnt += 1",
            "    stamp[s][0] = cnt",
            "    # euler.append(s+1)",
            "",
            "    seen[s] = True",
            "    for to in graph[s]:",
            "        if seen[to]:",
            "            continue",
            "        dfs(to)",
            "        # euler.append(s+1)",
            "",
            "    # 帰りがけ",
            "    cnt += 1",
            "    stamp[s][1] = cnt",
            "",
            "N = int(input())",
            "graph = [[] for _ in range(N)]",
            "for _ in range(N-1):",
            "    a,b =map(int,input().split())",
            "    a,b = a-1,b-1",
            "    graph[a].append(b)",
            "    graph[b].append(a)",
            "",
            "for i in range(N):",
            "    graph[i].sort()",
            "",
            "stamp = [[0,0] for _ in range(N)]",
            "seen = [False]*N",
            "cnt = 0",
            "euler = []",
            "dfs(0)",
            "print(*euler)",
        ],
        "description": "行きがけ/帰りがけのタイムスタンプを取得するDFS(オイラーツアーも可能)"
    },
    "dfs_treeTraversal": {
        "scope": "python",
        "prefix": "dfs_treeTraversal",
        "body": [
            "# Pythonで提出!!",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "class Node:",
            "    def __init__(self, val):",
            "        self.val = val",
            "        self.next = None",
            "        self.prev = None",
            "",
            "# 行きがけ/通りがけ/帰りがけの順序を出力",
            "def dfs(s):",
            "    if s:",
            "        order[0].append(s.val) # 行きがけ",
            "        dfs(s.prev)",
            " ",
            "        order[1].append(s.val) # 通りがけ",
            "",
            "        dfs(s.next)",
            "        order[2].append(s.val) # 通りがけ",
            "",
            "N =int(input())",
            "S = input()",
            "",
            "nodes = [Node(i) for i in range(N+1)]",
            "for i in range(len(S)):",
            "    if S[i] == \"R\":",
            "        nodes[i].next = nodes[i+1]",
            "    else:",
            "        nodes[i].prev = nodes[i+1]",
            "",
            "order = [[] for _ in range(3)]",
            "dfs(nodes[0])",
            "print(order)",
        ],
        "description": "Nodeで構築した二分木に対して行きがけ/通りがけ/帰りがけの順序を出力"
    },
    "dfs_stairs": {
        "scope": "python",
        "prefix": "dfs_stairs",
        "body": [
            "# Pythonで提出!!",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def dfs(n):",
            "    if n == N:",
            "        return 1",
            "    if seen[n]:",
            "        return seen[n]",
            "",
            "    if n+L <= N:",
            "        seen[n] = (seen[n]+dfs(n+L)+dfs(n+1))%(10**9+7)",
            "    elif n+1 <= N:",
            "        seen[n] = (seen[n]+dfs(n+1))%(10**9+7)",
            "",
            "    return seen[n]",
            "",
            "N,L = map(int,input().split())",
            "seen = [0]*(N+1)",
            "print(dfs(0))",
        ],
        "description": "階段の上り方(1段orL段)の数え上げ"
    },
    "bfs_maze": {
        "scope": "rust",
        "prefix": "bfs_maze",
        "body": [
            "input! {",
            "    (R,C):(isize,isize),",
            "    (sy,sx,gy,gx):(Isize1,Isize1,Isize1,Isize1),",
            "    maze:[Chars;R]",
            "}",
            "",
            "let mut dist:Vec<Vec<isize>> = vec![vec![-1;C as usize];R as usize];",
            "fn bfs(R:isize, C:isize, sy:isize, sx:isize, gy:isize, gx:isize, maze:&Vec<Vec<char>>, dist:&mut Vec<Vec<isize>>){",
            "    let MOVE = [[1, 0], [-1, 0], [0, 1], [0, -1]];",
            "    // let MOVE = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]; // 縦横斜め移動",
            "    let mut que = VecDeque::<(isize,isize)>::new();",
            "    que.push_back((sy,sx));",
            "    dist[sy as usize][sx as usize] = 0;",
            "    while !que.is_empty(){",
            "        let (y,x) = que.pop_front().unwrap();",
            "        if (y,x) == (gy,gx){",
            "            println!(\"{}\",dist[gy as usize][gx as usize]);",
            "            exit;",
            "        }",
            "        for &[dy,dx] in &MOVE{",
            "            let (ny,nx) = (y+dy,x+dx);",
            "            if 0 <= ny && ny < R && 0 <= nx && nx < C && maze[ny as usize][nx as usize] != '#' && dist[ny as usize][nx as usize] == -1{",
            "                dist[ny as usize][nx as usize] = dist[y as usize][x as usize] + 1;",
            "                que.push_back((ny,nx));",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "bfs(R,C,sy,sx,gy,gx,&maze, &mut dist);",
        ],
        "description": "迷路の探索(縦横移動のみ、周囲は全て壁、必ずGにたどり着ける前提)"
    },
    "bfs_graph": {
        "scope": "rust",
        "prefix": "bfs_graph",
        "body": [
            "let mut dist:Vec<isize> = vec![-1;N];",
            "fn bfs(s:usize, graph:&Vec<Vec<usize>>, dist:&mut Vec<isize>){",
            "    let mut que = VecDeque::<usize>::new();",
            "    que.push_back(s);",
            "    dist[s] = 0;",
            "    while !que.is_empty(){",
            "        let s = que.pop_front().unwrap();",
            "        for &to in &graph[s]{",
            "            if dist[to] != -1 {continue}",
            "            dist[to] = dist[s] + 1;",
            "            que.push_back(to);",
            "        }",
            "    }",
            "}",
            "",
            "bfs(0,&graph, &mut dist);",
        ],
        "description": "グラフの幅優先探索 O(N+M)"
    },
    "bfs_multiStart": {
        "scope": "python",
        "prefix": "bfs_multiStart",
        "body": [
            "from collections import deque",
            "",
            "move = ([1, 0], [-1, 0], [0, 1], [0, -1])",
            "def bfs_MultiStart(s):",
            "    global cnt_black",
            "    queue = deque(s)",
            "",
            "    ans = 0",
            "    while queue:",
            "        if cnt_black == H*W:",
            "            return ans",
            "        ans += 1",
            "        for _ in range(len(queue)):",
            "            y,x = queue.popleft()",
            "            for dy,dx in move:",
            "                ny,nx = y+dy,x+dx",
            "                if 0<=ny<H and 0<=nx<W and A[ny][nx] == \".\":",
            "                    A[ny][nx] = \"#\"",
            "                    cnt_black += 1",
            "                    queue.append((ny, nx))",
        ],
        "description": "多始点BFS"
    },
    "bfs_01": {
        "scope": "python",
        "prefix": "bfs_01",
        "body": [
            "from collections import deque",
            "",
            "def bfs_01(s):",
            "    que = deque([s])",
            "    while que:",
            "        s = que.popleft()",
            "        for to, w in edges[s]:",
            "            d = dist[i] + w",
            "            if d < dist[to]:",
            "                dist[to] = d",
            "                if w == 1:",
            "                    que.append(to)",
            "                else:",
            "                    que.appendleft(to)",
            "",
            "# 頂点数N、始点の頂点番号s",
            "N, s = map(int, input().split())",
            "# 隣接リスト。",
            "# edges[i]の要素に(j, c)が含まれる時、iからjにコストcの辺が存在",
            "edges = [[] for i in range(N)]",
            "",
            "dist = [10**9]*N",
            "dist[s] = 0",
            "bfs_01(s)",
        ],
        "description": "01BFS"
    },
    "topological_sort": {
        "scope": "python",
        "prefix": "topological_sort",
        "body": [
            "# V: 頂点数",
            "# G[v] = [w, ...]:",
            "#    有向グラフ上の頂点vから到達できる頂点w",
            "# deg[v]:",
            "#    頂点vに到達できる頂点の数",
            "",
            "from collections import deque",
            "ans = list(v for v in range(V) if deg[v]==0)",
            "deq = deque(ans)",
            "used = [0]*V",
            "",
            "while deq:",
            "    v = deq.popleft()",
            "    for t in g[v]:",
            "        deg[t] -= 1",
            "        if deg[t]==0:",
            "            deq.append(t)",
            "            ans.append(t)",
            "",
            "# ans: トポロジカル順序に並べた頂点",
        ],
        "description": "トポロジカルソート"
    },
    "FloydsCycleDetection": {
        "scope": "python",
        "prefix": "FloydsCycleDetection",
        "body": [
            "# フロイドの循環検出",
            "class Node:",
            "    def __init__(self, val):",
            "        self.val = val",
            "        self.next = None",
            "        self.prev = None",
            "",
            "# サイクル(閉路)があるか判定",
            "def hasCycle(head):",
            "    fast = slow = head",
            "    while fast and fast.next:",
            "        fast = fast.next.next",
            "        slow = slow.next",
            "        if fast == slow:",
            "            return True",
            "    return False",
            "",
            "# サイクル(閉路)の開始地点を探索",
            "def findCycleStart(head):",
            "    fast = slow = head",
            "    while fast and fast.next:",
            "        fast = fast.next.next",
            "        slow = slow.next",
            "        if fast == slow:",
            "            fast = head",
            "            while fast != slow:",
            "                fast = fast.next",
            "                slow = slow.next",
            "            return fast.val",
            "    return None",
            "",
            "# サイクルのループ長を探索",
            "def findCycleLen(head):",
            "    fast = slow = head",
            "    count = 0",
            "    while fast and fast.next:",
            "        count += 1",
            "        fast = fast.next.next",
            "        slow = slow.next",
            "        if fast == slow:",
            "            return count",
            "    return False",
            "",
            "N,K = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "",
            "nodes = [Node(i) for i in range(N)]",
            "for i in range(N):",
            "    nodes[i].next = nodes[(i+A[i])%N]",
            "",
            "# サイクル開始位置と1サイクルの長さを求める",
            "cycleStart = findCycleStart(nodes[0])",
            "cycleLen = findCycleLen(nodes[cycleStart])",
            "",
            "# 1サイクル分の合計",
            "cycleTotal = A[cycleStart]",
            "idx = nodes[cycleStart].next.val",
            "while idx != cycleStart:",
            "    cycleTotal += A[idx]",
            "    idx = nodes[idx].next.val",
            "",
            "ans = 0",
            "# サイクル開始地点までの合計",
            "idx = 0",
            "while idx != cycleStart:",
            "    ans += A[idx]",
            "    idx = nodes[idx].next.val",
            "    K -= 1",
            "    if K == 0:",
            "        print(ans)",
            "        exit()",
            "",
            "# サイクル内ループの合計",
            "ans += cycleTotal * (K // cycleLen)",
            "K %= cycleLen",
            "",
            "# サイクル内ループの余り分の合計",
            "idx = cycleStart",
            "while K > 0:",
            "    ans += A[idx]",
            "    idx = nodes[idx].next.val",
            "    K -= 1",
            "print(ans)",
        ],
        "description": "フロイドの循環検出"
    },
    "CycleSum": {
        "scope": "python",
        "prefix": "CycleSum",
        "body": [
            "N,X,M = map(int,input().split())",
            "",
            "li = [X]",
            "loop_start = 0",
            "check = set([X])",
            "for i in range(N):",
            "    nxt = pow(li[-1],2,M)",
            "    if nxt in check:",
            "        loop_start = li.index(nxt)",
            "        break",
            "    li.append(nxt)",
            "    check.add(nxt)",
            "",
            "loop_len = len(li)-loop_start",
            "r = (N-loop_start)//loop_len",
            "d = (N-loop_start)%loop_len",
            "ini_sum = sum(li[:loop_start])",
            "loop_sum = sum(li[loop_start:])*r",
            "mod_sum = sum(li[loop_start:loop_start+d])",
            "print(ini_sum + loop_sum + mod_sum)",
        ],
        "description": "サイクルを持つリストの和を求める"
    },
    "MaxFlow(Dinitz)": {
        "scope": "rust",
        "prefix": "MaxFlow(Dinitz)",
        "body": [
            "// 拝借元　https://github.com/kenkoooo/competitive-programming-rs/blob/master/src/graph/maximum_flow.rs",
            "pub mod dinitz {",
            "    const INF: i64 = 1 << 60;",
            "    pub struct Edge {",
            "        pub to: usize,",
            "        pub rev: usize,",
            "        pub is_reversed: bool,",
            "        pub cap: i64,",
            "    }",
            "",
            "    pub struct Dinitz {",
            "        pub g: Vec<Vec<Edge>>,",
            "    }",
            "",
            "    impl Dinitz {",
            "        pub fn new(v: usize) -> Dinitz {",
            "            let mut g: Vec<Vec<Edge>> = Vec::new();",
            "            for _ in 0..v {",
            "                g.push(Vec::new());",
            "            }",
            "            Dinitz { g }",
            "        }",
            "",
            "        pub fn add_edge(&mut self, from: usize, to: usize, cap: i64) {",
            "            let to_len = self.g[to].len();",
            "            let from_len = self.g[from].len();",
            "            self.g[from].push(Edge {",
            "                to,",
            "                rev: to_len,",
            "                is_reversed: false,",
            "                cap,",
            "            });",
            "            self.g[to].push(Edge {",
            "                to: from,",
            "                rev: from_len,",
            "                is_reversed: true,",
            "                cap: 0,",
            "            });",
            "        }",
            "",
            "        fn dfs(",
            "            &mut self,",
            "            v: usize,",
            "            sink: usize,",
            "            flow: i64,",
            "            level: &[i32],",
            "            iter: &mut [usize],",
            "        ) -> i64 {",
            "            if v == sink {",
            "                return flow;",
            "            }",
            "            while iter[v] < self.g[v].len() {",
            "                let flow = std::cmp::min(flow, self.g[v][iter[v]].cap);",
            "                let to = self.g[v][iter[v]].to;",
            "                if flow > 0 && level[v] < level[to] {",
            "                    let flowed = self.dfs(to, sink, flow, level, iter);",
            "                    if flowed > 0 {",
            "                        let rev = self.g[v][iter[v]].rev;",
            "                        self.g[v][iter[v]].cap -= flowed;",
            "                        self.g[to][rev].cap += flowed;",
            "                        return flowed;",
            "                    }",
            "                }",
            "                iter[v] += 1;",
            "            }",
            "            0",
            "        }",
            "",
            "        fn bfs(&self, s: usize) -> Vec<i32> {",
            "            let v = self.g.len();",
            "            let mut level = vec![-1; v];",
            "            level[s] = 0;",
            "            let mut deque = std::collections::VecDeque::new();",
            "            deque.push_back(s);",
            "            while let Some(v) = deque.pop_front() {",
            "                for e in self.g[v].iter() {",
            "                    if e.cap > 0 && level[e.to] < 0 {",
            "                        level[e.to] = level[v] + 1;",
            "                        deque.push_back(e.to);",
            "                    }",
            "                }",
            "            }",
            "            level",
            "        }",
            "",
            "        pub fn max_flow(&mut self, s: usize, t: usize) -> i64 {",
            "            let v = self.g.len();",
            "            let mut flow: i64 = 0;",
            "            loop {",
            "                let level = self.bfs(s);",
            "                if level[t] < 0 {",
            "                    return flow;",
            "                }",
            "                let mut iter = vec![0; v];",
            "                loop {",
            "                    let f = self.dfs(s, t, INF, &level, &mut iter);",
            "                    if f == 0 {",
            "                        break;",
            "                    }",
            "                    flow += f;",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "let mut flow = dinitz::Dinitz::new(N);",
            "for &(A,B,C) in &edges{",
            "    flow.add_edge(A, B, C);",
            "}",
            "",
            "println!(\"{}\",flow.max_flow(0, N-1));",
        ],
        "description": "最大フロー(Dinitzのアルゴリズム)"
    },
    "bipartite_matching": {
        "scope": "rust",
        "prefix": "bipartite_matching",
        "body": [
            "// 拝借元　https://github.com/kenkoooo/competitive-programming-rs/blob/master/src/graph/maximum_flow.rs",
            "pub mod dinitz {",
            "    const INF: i64 = 1 << 60;",
            "    pub struct Edge {",
            "        pub to: usize,",
            "        pub rev: usize,",
            "        pub is_reversed: bool,",
            "        pub cap: i64,",
            "    }",
            "",
            "    pub struct Dinitz {",
            "        pub g: Vec<Vec<Edge>>,",
            "    }",
            "",
            "    impl Dinitz {",
            "        pub fn new(v: usize) -> Dinitz {",
            "            let mut g: Vec<Vec<Edge>> = Vec::new();",
            "            for _ in 0..v {",
            "                g.push(Vec::new());",
            "            }",
            "            Dinitz { g }",
            "        }",
            "",
            "        pub fn add_edge(&mut self, from: usize, to: usize, cap: i64) {",
            "            let to_len = self.g[to].len();",
            "            let from_len = self.g[from].len();",
            "            self.g[from].push(Edge {",
            "                to,",
            "                rev: to_len,",
            "                is_reversed: false,",
            "                cap,",
            "            });",
            "            self.g[to].push(Edge {",
            "                to: from,",
            "                rev: from_len,",
            "                is_reversed: true,",
            "                cap: 0,",
            "            });",
            "        }",
            "",
            "        fn dfs(",
            "            &mut self,",
            "            v: usize,",
            "            sink: usize,",
            "            flow: i64,",
            "            level: &[i32],",
            "            iter: &mut [usize],",
            "        ) -> i64 {",
            "            if v == sink {",
            "                return flow;",
            "            }",
            "            while iter[v] < self.g[v].len() {",
            "                let flow = std::cmp::min(flow, self.g[v][iter[v]].cap);",
            "                let to = self.g[v][iter[v]].to;",
            "                if flow > 0 && level[v] < level[to] {",
            "                    let flowed = self.dfs(to, sink, flow, level, iter);",
            "                    if flowed > 0 {",
            "                        let rev = self.g[v][iter[v]].rev;",
            "                        self.g[v][iter[v]].cap -= flowed;",
            "                        self.g[to][rev].cap += flowed;",
            "                        return flowed;",
            "                    }",
            "                }",
            "                iter[v] += 1;",
            "            }",
            "            0",
            "        }",
            "",
            "        fn bfs(&self, s: usize) -> Vec<i32> {",
            "            let v = self.g.len();",
            "            let mut level = vec![-1; v];",
            "            level[s] = 0;",
            "            let mut deque = std::collections::VecDeque::new();",
            "            deque.push_back(s);",
            "            while let Some(v) = deque.pop_front() {",
            "                for e in self.g[v].iter() {",
            "                    if e.cap > 0 && level[e.to] < 0 {",
            "                        level[e.to] = level[v] + 1;",
            "                        deque.push_back(e.to);",
            "                    }",
            "                }",
            "            }",
            "            level",
            "        }",
            "",
            "        pub fn max_flow(&mut self, s: usize, t: usize) -> i64 {",
            "            let v = self.g.len();",
            "            let mut flow: i64 = 0;",
            "            loop {",
            "                let level = self.bfs(s);",
            "                if level[t] < 0 {",
            "                    return flow;",
            "                }",
            "                let mut iter = vec![0; v];",
            "                loop {",
            "                    let f = self.dfs(s, t, INF, &level, &mut iter);",
            "                    if f == 0 {",
            "                        break;",
            "                    }",
            "                    flow += f;",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "input! {",
            "    N:usize,",
            "    C:[Chars;N]",
            "}",
            "",
            "let s = 2*N;",
            "let t = s+1;",
            "let mut flow = dinitz::Dinitz::new(2*N+2);",
            "for i in 0..N{",
            "    flow.add_edge(s, i, 1);",
            "    flow.add_edge(N+i, t, 1);",
            "    for j in 0..N{",
            "        if C[i][j] == '#'{",
            "            flow.add_edge(i, N+j, 1);",
            "        }",
            "    }",
            "}",
            "",
            "println!(\"{}\",flow.max_flow(s,t));",
        ],
        "description": "2部マッチング"
    },
    "BIT": {
        "scope": "python",
        "prefix": "BIT",
        "body": [
            "# BIT(Fenwick Tree) ※一点加算、区間和のRSQ相当",
            "class BIT:",
            "    def __init__(self, n):",
            "        self._n = n",
            "        self.data = [0] * n",
            "",
            "    def add(self, p, x):",
            "        assert 0 <= p < self._n",
            "        p += 1",
            "        while p <= self._n:",
            "            self.data[p - 1] += x",
            "            p += p & -p",
            "",
            "    def sum(self, l, r):",
            "        assert 0 <= l <= r <= self._n",
            "        return self._sum(r) - self._sum(l)",
            "",
            "    def _sum(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s += self.data[r - 1]",
            "            r -= r & -r",
            "        return s",
            "",
            "'''",
            "bit = BIT(5) # 要素数5個の配列を0で初期化",
            "bit.add(1,3) # bit[1]に3を加算",
            "bit.add(2,5) # bit[2]に5を加算",
            "print(bit.sum(1,3)) # インデックス1から2(半閉半開区間)の要素の合計(=8)を取得",
            "print(bit.data) # [0,3,5,8,0]",
            "'''",
        ],
        "description": "Binary Indexed Tree(Fenwick Tree)　※一点加算、区間和のRSQ相当"
    },
    "SegTree_Abstract": {
        "scope": "rust",
        "prefix": "SegTree_Abstract",
        "body": [
            "/// https://github.com/akiradeveloper/rust-comp-snippets/blob/master/src/seg.rs",
            "/// フェニック木の一般化",
            "/// 各ノードには最初、idに相当する値が入っている。",
            "/// let mut seg:SEG<SUM> = SEG::new(N);",
            "/// get i: a[i]を返す",
            "/// update i x: a[i]=x",
            "/// query l r: [l,r)をカバーするノードに対してopを適用したもの",
            "",
            "pub trait Monoid {",
            "    type T: Clone + std::fmt::Debug;",
            "    fn id() -> Self::T;",
            "    fn op(a: &Self::T, b: &Self::T) -> Self::T;",
            "}",
            "",
            "pub struct SEG<M: Monoid> {",
            "    pub n: usize,",
            "    pub buf: Vec<M::T>,",
            "}",
            "",
            "impl<M: Monoid> SEG<M> {",
            "    pub fn new(n: usize) -> SEG<M> {",
            "        let mut m = 1;",
            "        while m < n { m *= 2; }",
            "        SEG {",
            "            n: m,",
            "            buf: vec![M::id().clone(); 2 * m],",
            "        }",
            "    }",
            "",
            "    pub fn update(&mut self, k: usize, a: M::T) {",
            "        let mut k = k + self.n;",
            "        self.buf[k] = a;",
            "",
            "        while k > 1 {",
            "            k = k >> 1;",
            "            self.buf[k] = M::op(&self.buf[k*2], &self.buf[k*2+1]);",
            "        }",
            "    }",
            "    ",
            "    pub fn get(&self, k: usize) -> M::T {",
            "        self.buf[k + self.n].clone()",
            "    }",
            "",
            "    pub fn do_query(&self, a: usize, b: usize, k: usize, l: usize, r: usize) -> M::T {",
            "        if r <= a || b <= l {",
            "            return M::id();",
            "        }",
            "",
            "        if a <= l && r <= b {",
            "            return self.buf[k].clone();",
            "        } else {",
            "            let vl = self.do_query(a,b,k*2,l,(l+r)/2);",
            "            let vr = self.do_query(a,b,k*2+1,(l+r)/2,r);",
            "            return M::op(&vl, &vr);",
            "        }",
            "    }",
            "",
            "    // [a,b)",
            "    pub fn query(&self, a: usize, b: usize) -> M::T {",
            "        self.do_query(a,b,1,0,self.n)",
            "    }",
            "}",
            "",
            "struct SUM;",
            "impl Monoid for SUM {",
            "    type T = i64;",
            "    fn id() -> Self::T {",
            "        0",
            "    }",
            "    fn op(a: &Self::T, b: &Self::T) -> Self::T {",
            "        *a + *b",
            "    }",
            "}",
            "",
            "struct MAX;",
            "impl Monoid for MAX {",
            "    type T = i64;",
            "    fn id() -> Self::T {",
            "        std::i64::MIN",
            "    }",
            "    fn op(a: &Self::T, b: &Self::T) -> Self::T {",
            "        max(*a, *b)",
            "    }",
            "}",
        ],
        "description": "抽象化セグメント木"
    },
    "RMQ_RUQ": {
        "scope": "python",
        "prefix": "RMQ_RUQ",
        "body": [
            "# N: 処理する区間の長さ",
            "",
            "INF = 2**31-1",
            "",
            "LV = (N-1).bit_length()",
            "N0 = 2**LV",
            "data = [INF]*(2*N0)",
            "lazy = [None]*(2*N0)",
            "",
            "# 伝搬対象の区間を求める",
            "def gindex(l, r):",
            "    L = (l + N0) >> 1; R = (r + N0) >> 1",
            "    lc = 0 if l & 1 else (L & -L).bit_length()",
            "    rc = 0 if r & 1 else (R & -R).bit_length()",
            "    for i in range(LV):",
            "        if rc <= i:",
            "            yield R",
            "        if L < R and lc <= i:",
            "            yield L",
            "        L >>= 1; R >>= 1",
            "",
            "# 遅延伝搬処理",
            "def propagates(*ids):",
            "    for i in reversed(ids):",
            "        v = lazy[i-1]",
            "        if v is None:",
            "            continue",
            "        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v",
            "        lazy[i-1] = None",
            "",
            "# 区間[l, r)をxで更新",
            "def update(l, r, x):",
            "    *ids, = gindex(l, r)",
            "    propagates(*ids)",
            "",
            "    L = N0 + l; R = N0 + r",
            "    while L < R:",
            "        if R & 1:",
            "            R -= 1",
            "            lazy[R-1] = data[R-1] = x",
            "        if L & 1:",
            "            lazy[L-1] = data[L-1] = x",
            "            L += 1",
            "        L >>= 1; R >>= 1",
            "    for i in ids:",
            "        data[i-1] = min(data[2*i-1], data[2*i])",
            "",
            "# 区間[l, r)内の最小値を求める",
            "def query(l, r):",
            "    propagates(*gindex(l, r))",
            "    L = N0 + l; R = N0 + r",
            "",
            "    s = INF",
            "    while L < R:",
            "        if R & 1:",
            "            R -= 1",
            "            s = min(s, data[R-1])",
            "        if L & 1:",
            "            s = min(s, data[L-1])",
            "            L += 1",
            "        L >>= 1; R >>= 1",
            "    return s",
        ],
        "description": "RMQ(区間最小)、RUQ(区間更新)"
    },
    "01knapsack": {
        "scope": "python",
        "prefix": "knapsack",
        "body": [
            "N,W = map(int,input().split())",
            "goods = [list(map(int,input().split())) for _ in range(N)]",
            "",
            "dp = [[0]*(W+1) for _ in range(N+1)]",
            "",
            "for i in range(N):",
            "    for j in range(W+1):",
            "        if j-goods[i][1] >= 0:",
            "            dp[i+1][j] = max(dp[i][j], dp[i][j-goods[i][1]] + goods[i][0]) # 0-1ナップザック",
            "            # dp[i+1][j] = max(dp[i][j], dp[i][j-goods[i][1]] + goods[i][0], dp[i+1][j-goods[i][1]] + goods[i][0]) # 重複あり",
            "        else:",
            "            dp[i+1][j] = dp[i][j]",
            "",
            "print(dp[N][W])",
            "",
        ],
        "description": "ナップザック問題"
    },
    "tree_dp1": {
        "scope": "rust",
        "prefix": "tree_dp1",
        "body": [
            "input! {",
            "    N:usize,",
            "    A:[Usize1;N-1]",
            "}",
            "",
            "let mut graph = vec![vec![];N];",
            "for (i,&a) in A.iter().enumerate(){",
            "    graph[i+1].push(a);",
            "    graph[a].push(i+1);",
            "}",
            "",
            "let mut dp = vec![0;N];",
            "fn dfs(s:usize, pre:usize, graph:&Vec<Vec<usize>>, dp:&mut Vec<usize>) {",
            "    for &to in &graph[s] {",
            "        if to != pre {",
            "            dfs(to,s, graph, dp);",
            "            dp[s] += dp[to] + 1;",
            "        }",
            "    }",
            "}",
            "",
            "dfs(0,INF, &graph, &mut dp);",
        ],
        "description": "木DP(各頂点が何個の子を持つかを求める)"
    },
    "tree_dp2": {
        "scope": "rust",
        "prefix": "tree_dp2",
        "body": [
            "input! {",
            "    N: usize,",
            "    T: Usize1,",
            "    edges: [(Usize1, Usize1); N-1]",
            "}",
            "",
            "let mut graph = vec![vec![];N];",
            "for &(A,B) in &edges{",
            "    graph[A].push(B);",
            "    graph[B].push(A);",
            "}",
            "",
            "let mut dp = vec![0;N];",
            "fn dfs(s:usize, pre:usize, graph:&Vec<Vec<usize>>, dp:&mut Vec<usize>) {",
            "    for &to in &graph[s] {",
            "        if to != pre {",
            "            dfs(to,s, graph, dp);",
            "            dp[s] = max(dp[s], dp[to]+1);",
            "        }",
            "    }",
            "}",
            "",
            "dfs(T,INF, &graph, &mut dp);",
        ],
        "description": "木DP(根から最も遠い頂点までの深さを求める)"
    },
    "TSP": {
        "scope": "rust",
        "prefix": "TSP",
        "body": [
            "    fn dist(pos1:(isize,isize),pos2:(isize,isize)) -> f64{",
            "        (((pos2.0-pos1.0)*(pos2.0-pos1.0) + (pos2.1-pos1.1)*(pos2.1-pos1.1)) as f64).sqrt()",
            "    }",
            "",
            "    let mut dp = vec![vec![INF as f64;N];1<<N];",
            "    dp[0][0] = 0.0;",
            "",
            "    for bit in 0..1<<N{",
            "        for s in 0..N{",
            "            for t in 0..N{",
            "                if bit != 0 && bit & (1<<s) == 0 {continue}",
            "                if bit & (1<<t) == 0 && s != t{",
            "                    dp[bit | 1<<t][t] = dp[bit | 1<<t][t].min(dp[bit][s] + dist(city[s],city[t]));",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    println!(\"{}\",dp[(1<<N)-1][0]);",
        ],
        "description": "TSP(巡回セールスマン問題)"
    },
    "doubling": {
        "scope": "rust",
        "prefix": "doubling",
        "body": [
            "let lv = 1<<5;",
            "let mut dp = vec![vec![0;N];lv+1]; //10^9 < 2^32",
            "for i in 0..N { dp[0][i] = A[i]; }",
            "for d in 0..lv {",
            "    for i in 0..N {",
            "        dp[d+1][i] = dp[d][dp[d][i]];",
            "    }",
            "}",
            "",
            "for &(X,Y) in &query{",
            "    let mut cur = X;",
            "    for d in (0..lv).rev() {",
            "        if (Y / (1<<d)) % 2 == 1 {",
            "            cur = dp[d][cur];",
            "        }",
            "    }",
            "    println!(\"{}\",cur+1);",
            "}",
        ],
        "description": "ダブリング"
    },
    "Zobrist Hash": {
        "scope": "python",
        "prefix": "Zobrist Hash",
        "body": [
            "# Zobrist Hash(ABC250 - E - Prefix Equality)",
            "import random",
            "",
            "N =int(input())",
            "A =list(map(int,input().split()))",
            "B =list(map(int,input().split()))",
            "Q =int(input())",
            "",
            "# リストの各要素をユニークな乱数に変換",
            "rand = {}",
            "for a,b in zip(A,B):",
            "    if a not in rand:",
            "        rand[a] = random.randrange(1 << 64)",
            "",
            "    if b not in rand:",
            "        rand[b] = random.randrange(1 << 64)",
            "",
            "# リストの先頭から順に集合の状態をハッシュ化(累積XOR)",
            "zhA,zhB = [0],[0]",
            "setA,setB = set(),set()",
            "for a,b in zip(A,B):",
            "    if a in setA:",
            "        zhA.append(zhA[-1])",
            "    else:",
            "        zhA.append(zhA[-1] ^ rand[a])",
            "        setA.add(a)",
            "",
            "    if b in setB:",
            "        zhB.append(zhB[-1])",
            "    else:",
            "        zhB.append(zhB[-1] ^ rand[b])",
            "        setB.add(b)",
            "",
            "# ハッシュ値を比較し、同じ集合か判定",
            "for _ in range(Q):",
            "    x,y = map(int, input().split())",
            "    if zhA[x] == zhB[y]:",
            "        print(\"Yes\")",
            "    else:",
            "        print(\"No\")",
        ],
        "description": "Zobrist Hash(状態をハッシュ化)"
    },
}
