{
    "Template_AtCoder": {
        "scope": "python",
        "prefix": "Template_AtCoder",
        "body": [
            "import sys",
            "input = lambda: sys.stdin.readline().rstrip()",
            "INF = 10**18",
            "",
            "",
        ],
        "description": "AtCoder template"
    },
    "Template_Codeforces": {
        "scope": "python",
        "prefix": "Template_Codeforces",
        "body": [
            "import sys",
            "input = lambda: sys.stdin.readline().rstrip()",
            "sys.setrecursionlimit(10**5)",
            "import random",
            "XOR=random.randint(10**7,10**8)",
            "INF = 10**18",
            "",
            "def solve():",
            "    N = int(input())",
            "",
            "Q = int(input())",
            "for _ in range(Q):",
            "    solve()",
        ],
        "description": "Codeforces template"
    },
    "FileInput": {
        "scope": "python",
        "prefix": "FileInput",
        "body": [
            "import sys",
            "stdin = open('tmp\\abcxxx_a\\sample-1.in')",
        ],
        "description": "FileInput"
    },
	"input_line int(single)":{
		"scope": "python",
        "prefix":"input_line int(single)",
		"body":[
            " int(input())"
        ],
		"description":"input int(single)",
	},
	"input_line int(multiple)":{
		"scope": "python",
        "prefix":"input_line int(multiple)",
		"body":[
            " map(int,input().split())"
        ],
		"description":"input int(multiple)",
	},
	"input_line list(int)":{
		"scope": "python",
        "prefix":"input_line list(int)",
		"body":[
            " list(map(int,input().split()))"
        ],
		"description":"input list(int)",
	},
    "input_lines list(int)":{
		"scope": "python",
        "prefix":"input_lines list(int)",
		"body":[
            " [int(input()) for _ in range($1)]"
        ],
		"description":"input_lines list(int)",
	},
	"input_lines list(multiple_int)":{
		"scope": "python",
        "prefix":"input_lines list(multiple_int)",
		"body":[
            " [list(map(int,input().split())) for _ in range($1)]"
        ],
		"description":"input_lines list(multiple_int)",
	},
	"input_line list(string)":{
		"scope": "python",
        "prefix":"input_line list(string)",
		"body":[
            " list(input())"
        ],
		"description":"input line list(string)",
	},
    "input_lines list(string)":{
		"scope": "python",
        "prefix":"input_lines list(string)",
		"body":[
            " [list(input()) for _ in range($1)]"
        ],
		"description":"input_lines list(string)",
	},
    "input_tree": {
        "scope": "python",
        "prefix": "input_tree",
        "body": [
            "N = int(input())",
            "graph = [[] for _ in range(N)]",
            "for _ in range(N-1):",
            "    a,b = map(int,input().split())",
            "    a,b = a-1,b-1",
            "    graph[a].append(b)",
            "    graph[b].append(a)",
        ],
        "description": "N頂点の木の入力"
    },
    "input_graph": {
        "scope": "python",
        "prefix": "input_graph",
        "body": [
            "N,M = map(int,input().split())",
            "graph = [[] for _ in range(N)]",
            "for _ in range(M):",
            "    a,b = map(int,input().split())",
            "    a,b = a-1,b-1",
            "    graph[a].append(b)",
            "    graph[b].append(a)",
        ],
        "description": "N頂点M辺のグラフの入力"
    },
    "print":{
		"scope": "python",
        "prefix":"print",
		"body":["print($1)"],
		"description":"print",
	},
    "print_sep":{
		"scope": "python",
        "prefix":"print_sep",
		"body":["print(*$1, sep=\"\\n\")"],
		"description":"print_sep",
	},
    "print_YesNo": {
        "scope": "python",
        "prefix": "print_YesNo",
        "body": [
            "print([\"No\",\"Yes\"][$1])",
        ],
        "description": "print_YesNo"
    },
    "print_YESNO": {
        "scope": "python",
        "prefix": "print_YESNO",
        "body": [
            "print([\"NO\",\"YES\"][$1])",
        ],
        "description": "print_YESNO"
    },
    "debug": {
        "scope": "python",
        "prefix": "debug_comment",
        "body": [
            "import sys",
            "def debug(*args): print(*args, file=sys.stderr)",
        ],
        "description": "デバッグ用コメント出力関数"
    },
    "deque": {
        "scope": "python",
        "prefix": "deque",
        "body": [
            "from collections import deque",
            "d = deque($1)",
        ],
        "description": "deque"
    },
    "DoublyLinkedList": {
        "scope": "python",
        "prefix": "DoublyLinkedList",
        "body": [
            "class Node:",
            "    def __init__(self, val):",
            "        self.val = val",
            "        self.next = None",
            "        self.prev = None",
            "",
            "class DoublyLinkedList:",
            "    def __init__(self):",
            "        self.head = None",
            "        self.tail = None",
            "        self.length = 0",
            "",
            "    def append(self,val):",
            "        newNode = Node(val)",
            "        if (not self.head):",
            "            self.head = newNode",
            "            self.tail = self.head",
            "        else:",
            "            self.tail.next = newNode",
            "            newNode.prev = self.tail",
            "            self.tail = newNode",
            "",
            "        self.length += 1",
            "        return self",
            "",
            "    def pop(self):",
            "        if(not self.head):",
            "            return None",
            "",
            "        currentTail = self.tail",
            "        if (self.length == 1):",
            "            self.tail = None",
            "            self.head = None",
            "        else:",
            "            self.tail = self.tail.prev",
            "            self.tail.next = None",
            "            currentTail.prev = None",
            "",
            "        self.length -= 1",
            "        return currentTail",
            "",
            "    def popleft(self):",
            "        if (self.length == 0):",
            "            return None",
            "        oldHead = self.head",
            "        if (self.length == 1):",
            "            self.head = None",
            "            self.tail = None",
            "        else:",
            "            self.head = oldHead.next",
            "",
            "        self.length -= 1",
            "        return oldHead",
            "",
            "    def appendleft(self, val):",
            "        newNode = Node(val)",
            "        if (self.length == 0):",
            "            self.head = newNode",
            "            self.tail = newNode",
            "        else:",
            "            self.head.prev = newNode",
            "            newNode.next = self.head",
            "            self.head = newNode",
            "        self.length += 1",
            "        return self",
            "",
            "    def find(self, val):",
            "        current = self.head",
            "        index = 0",
            "        while current is not None:",
            "            if current.val == val:",
            "                return index",
            "            current = current.next",
            "            index += 1",
            "        return -1",
            "",
            "    def get(self, index):",
            "        if ((index < 0) or (index > self.length)):",
            "            return None",
            "",
            "        halfOfLength = self.length // 2",
            "        if (index <= halfOfLength):",
            "            counter = 0",
            "            current = self.head",
            "            while(counter != index):",
            "                current = current.next",
            "                counter = counter + 1",
            "            return current",
            "        elif (index > halfOfLength):",
            "            counter = self.length - 1",
            "            current = self.tail",
            "            while(counter != index):",
            "                current = current.prev",
            "                counter = counter - 1",
            "            return current",
            "",
            "    def set(self, index, val):",
            "        targetNode = self.get(index)",
            "        if(targetNode):",
            "            targetNode.val = val",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    def insert(self, index, val):",
            "        if((index < 0) or (index > self.length)):",
            "            return False",
            "        if (index == 0):",
            "            self.appendleft(val)",
            "        if (index == self.length):",
            "            self.append(val)",
            "        prevNode = self.get(index - 1)",
            "        newNode = Node(val)",
            "        nextNode = prevNode.next",
            "        prevNode.next = newNode",
            "        newNode.prev = prevNode",
            "        nextNode.prev = newNode",
            "        newNode.next = nextNode",
            "        self.length += 1",
            "",
            "        return True",
            "",
            "    def remove(self, index):",
            "        removedNode = None",
            "        if((index < 0) or (self.length <= index)):",
            "            return None",
            "        elif (index == 0):",
            "            removedNode = self.popleft()",
            "        elif (index == self.length - 1):",
            "            removedNode = self.pop()",
            "        else:",
            "            removedNode = self.get(index)",
            "            removedNode.prev.next = removedNode.next",
            "            removedNode.next.prev = removedNode.prev",
            "            removedNode.next = None",
            "            removedNode.prev = None",
            "            self.length -= 1",
            "        return removedNode",
            "",
            "    def reverse(self):",
            "        node = self.head",
            "        self.head = self.tail",
            "        self.tail = node",
            "",
            "        tmpPrev = None",
            "        tmpNext = None",
            "        while(node):",
            "            tmpPrev = node.prev",
            "            tmpNext = node.next",
            "            node.next = tmpPrev",
            "            node.prev = tmpNext",
            "            node = node.prev",
            "",
            "        return self",
            "",
            "    def show(self):",
            "        temp = self.head",
            "        arr = []",
            "        for _ in range(self.length):",
            "            arr.append(temp.val)",
            "            temp = temp.next",
            "        print(*arr)",
        ],
        "description": "双方向連結リスト"
    },
    "heapq": {
        "scope": "python",
        "prefix": "heapq",
        "body": [
            "from heapq import heapify, heappush, heappop, heappushpop, heapreplace, nlargest, nsmallest  # heapqライブラリのimport",
            "",
            "'''",
            "a = [1, 6, 8, 0, -1]",
            "heapify(a)  # リストを優先度付きキューへ(リストが空の場合はheapify()不要)",
            "heappop(a)  # 最小値の取り出し",
            "heappush(a, -2)  # 要素の挿入",
            "nlargest(3, a) #リストから大きい順に3個取り出し([8,6,1])",
            "'''",
        ],
        "description": "heapq(priority queue)"
    },
    "SortedSet": {
        "scope": "python",
        "prefix": "SortedSet",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
            "import math",
            "from bisect import bisect_left, bisect_right",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedSet(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(set(a))",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedSet\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def add(self, x: T) -> bool:",
            "        \"Add an element and return True if added. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return True",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i != len(a) and a[i] == x: return False",
            "        a.insert(i, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "        return True",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "    ",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "    ",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": "SortedSet(順序付きset)。重複を許さない。"
    },
    "SortedMultiSet": {
        "scope": "python",
        "prefix": "SortedMultiSet",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
            "import math",
            "from bisect import bisect_left, bisect_right, insort",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedMultiset(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(a)",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedMultiset\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def count(self, x: T) -> int:",
            "        \"Count the number of x.\"",
            "        return self.index_right(x) - self.index(x)",
            "",
            "    def add(self, x: T) -> None:",
            "        \"Add an element. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return",
            "        a = self._find_bucket(x)",
            "        insort(a, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": "SortedMultiSet(順序付きマルチセット)。重複を許す。"
    },
    "sort_with_index": {
        "scope": "python",
        "prefix": "sort_with_index",
        "body": [
            "def sort_with_index(arr, reverse=False):",
            "    if reverse:",
            "        return sorted([ (x,i) for i, x in enumerate(arr)], reverse=True)",
            "    else:",
            "        return sorted([ (x,i) for i, x in enumerate(arr)])",
        ],
        "description": "index付きソート"
    },
    "sort_multiple": {
        "scope": "python",
        "prefix": "sort_multiple",
        "body": [
            "# 昇順降順を入れ替える場合はlambda式の正負を反転",
            "$1.sort(key=lambda x:(-x[1],x[0]))",
        ],
        "description": "多次元リストのソート"
    },
    "rotate_2d": {
        "scope": "python",
        "prefix": "rotate_2d",
        "body": [
            "# 二次元配列の90度右回転",
            "def rotate_2d(arr):",
            "    return zip(*arr[::-1])",
            "",
        ],
        "description": "二次元配列の90度右回転"
    },
    "inverse_2d": {
        "scope": "python",
        "prefix": "inverse_2d",
        "body": [
            "inv = list(zip(*$1))",
        ],
        "description": "二次元配列の転置"
    },
    "RunLengthEncoding": {
        "scope": "python",
        "prefix": "RunLengthEncoding",
        "body": [
            "def RunLengthEncoding(S):",
            "    cur = S[0]",
            "    cnt = 1",
            "    res = []",
            "    for i in range(1,len(S)):",
            "        if cur == S[i]:",
            "            cnt += 1",
            "        else:",
            "            res.append((cur,cnt))",
            "            cur = S[i]",
            "            cnt = 1",
            "    res.append((cur,cnt))",
            "    return res",
        ],
        "description": "ランレングス圧縮"
    },
    "baisuu": {
        "scope": "python",
        "prefix": "baisuu(multiples)",
        "body": [
            "2の倍数：1の位が2,4,6,8,0",
            "3の倍数：各桁の数字の和が3の倍数",
            "4の倍数：下2桁が4の倍数",
            "5の倍数：1の位が5,0",
            "6の倍数：2の倍数かつ3の倍数",
            "7の倍数：3桁ごとに区切った数字を1つ飛ばしに足した和の差が7の倍数",
            "8の倍数：下3桁が8の倍数",
            "9の倍数：各桁の数字の和が9の倍数",
            "11の倍数：(奇数桁目の数字の和)-(偶数桁目の数字の和)が11の倍数か0",
            "13の倍数：3桁ごとに区切った数字を1つ飛ばしに足した和の差が13の倍数",
        ],
        "description": "倍数判別法"
    },
    "ceil": {
        "scope": "python",
        "prefix": "ceil",
        "body": [
            "-(-($1)//)",
        ],
        "description": "ceil(切り上げ除算)"
    },
    "mod_1000000007": {
        "scope": "python",
        "prefix": "mod_1000000007",
        "body": [
            "MOD = 10**9+7",
        ],
        "description": "数え上げでよく使う数値その1"
    },
    "mod_998244353": {
        "scope": "python",
        "prefix": "mod_998244353",
        "body": [
            "MOD = 998244353",
        ],
        "description": "数え上げでよく使う数値その2"
    },
    "round_half_up": {
        "scope": "python",
        "prefix": "round_half_up",
        "body": [
            "from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN",
            "f = 123.456",
            "print(Decimal(str(f)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))",
            "#123",
            "print(Decimal(str(f)).quantize(Decimal('0.1'), rounding=ROUND_HALF_UP))",
            "#123.5",
            "print(Decimal(str(f)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
            "#123.46",
        ],
        "description": "四捨五入"
    },
    "gcd": {
        "scope": "python",
        "prefix": "gcd",
        "body": [
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    else:",
            "        return gcd(b,a%b)",
        ],
        "description": "a,bの最大公約数"
    },
    "gcdlist": {
        "scope": "python",
        "prefix": "gcdlist",
        "body": [
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    else:",
            "        return gcd(b,a%b)",
            "",
            "def gcdlist(l):",
            "    a = l[0]",
            "    for i in range(len(l)):",
            "        a = gcd(a,l[i])",
            "    return a",
        ],
        "description": "リスト l の最大公約数"
    },
    "lcm": {
        "scope": "python",
        "prefix": "lcm",
        "body": [
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    else:",
            "        return gcd(b,a%b)",
            "",
            "def lcm(a, b):",
            "    return a * b // gcd (a, b)",
        ],
        "description": "a,bの最小公倍数"
    },
    "lcmlist": {
        "scope": "python",
        "prefix": "lcmlist",
        "body": [
            "def gcd(a,b):",
            "    if b == 0:",
            "        return a",
            "    else:",
            "        return gcd(b,a%b)",
            "",
            "def lcmlist(l):",
            "    a = l[0]",
            "    for i in range(1, len(l)):",
            "        a = (a * l[i]) // gcd(a, l[i])",
            "    return a",
        ],
        "description": "リスト l の最小公倍数"
    },
    "digsum": {
        "scope": "python",
        "prefix": "digsum",
        "body": [
            "def digsum(n):",
            "    res = 0",
            "    while n > 0:",
            "        res += n%10",
            "        n //= 10",
            "    ",
            "    return res",
        ],
        "description": "桁和"
    },
    "base_n": {
        "scope": "python",
        "prefix": "base_n",
        "body": [
            "# 10進数⇒2,8,16進数",
            "x = 10",
            "bin_x = bin(x)[2:]",
            "oct_x = oct(x)[2:]",
            "hex_x = hex(x)[2:]",
            "",
            "# 10進数⇒n進数",
            "def base10int(value, base):",
            "    if value >= base:",
            "        return base10int(value//base, base) + str(value % base)",
            "    return str(value % base)",
            "",
            "# 10進数⇒n進数(返り値リスト)",
            "def base10int_list(value, base):",
            "    upper = value >= base and base10int_list(value // base, base) or []",
            "    return upper + [value % base]  # リストの結合",
            "",
            "# n進数⇒10進数",
            "# 2<=n<=36の時は、Python組み込みのint関数を使用",
            "# int(value, base)",
            "",
            "# 前処理として、各桁の値を格納したリストが必要",
            "# digits = list(str(value))",
            "def decode(digits, base):",
            "    value = 0",
            "    for digit in digits:",
            "        value = value * base + int(digit)",
            "    return value",
            "",
        ],
        "description": "進数変換"
    },
    "divisor": {
        "scope": "python",
        "prefix": "divisor",
        "body": [
            "def divisor(n):",
            "    lower_divisors , upper_divisors = [], []",
            "    i = 1",
            "    while i*i <= n:",
            "        if n % i == 0:",
            "            lower_divisors.append(i)",
            "            if i != n // i:",
            "                upper_divisors.append(n//i)",
            "        i += 1",
            "    return lower_divisors + upper_divisors[::-1]",
        ],
        "description": "nの約数を全て求める(O(√N))"
    },
    "mcb": {
        "scope": "python",
        "prefix": "mcb",
        "body": [
            "def mcb(N):",
            "    L,R = 1, 10**5+1 # Nの桁数によってRの桁数も変化(例：N=10^15　⇒　R=10^5+1)",
            "    while R-L > 1:",
            "        mid=(L+R)/2",
            "        if mid*mid*mid <= N:",
            "            L=mid",
            "        else:",
            "            R=mid",
            "    return L",
        ],
        "description": "三乗根"
    },
    "prime_decomposition": {
        "scope": "python",
        "prefix": "prime_decomposition",
        "body": [
            "def prime_decomposition(n):",
            "    i = 2",
            "    table = []",
            "    while i * i <= n:",
            "      while n % i == 0:",
            "        n = n//i",
            "        table.append(i)",
            "      i += 1",
            "    if n > 1:",
            "      table.append(n)",
            "    return table",
        ],
        "description": "nを素因数分解したリストを返す"
    },
    "is_prime": {
        "scope": "python",
        "prefix": "is_prime",
        "body": [
            "def is_prime(n):",
            "    for i in range(2, n + 1):",
            "        if i * i > n:",
            "            break",
            "        if n % i == 0:",
            "            return False",
            "    return n != 1",
        ],
        "description": "素数判定"
    },
    "sieve": {
        "scope": "python",
        "prefix": "sieve",
        "body": [
            "def sieve(n):",
            "    is_prime = [True for _ in range(n+1)]",
            "    is_prime[0] = False",
            "    is_prime[1] = False",
            "",
            "    for i in range(2, n+1):",
            "        if not is_prime[i]:",
            "            continue",
            "        for j in range(i*2, n+1, i):",
            "            is_prime[j] = False",
            "    table = [ i-1 for i in range(1, n+1) if is_prime[i-1]] # 素数のリスト",
            "    return table",
        ],
        "description": "エラトステネスの篩"
    },
    "pow_doubling": {
        "scope": "python",
        "prefix": "pow_doubling",
        "body": [
            "def pos(x, n, m):",
            "    if n == 0:",
            "        return 1",
            "    res = pos(x*x%m, n//2, m)",
            "    if n%2 == 1:",
            "        res = res*x%m",
            "    return res",
        ],
        "description": "高速べき乗計算"
    },
    "euler_phi": {
        "scope": "python",
        "prefix": "euler_phi",
        "body": [
            "def euler_phi(n):",
            "    res = n",
            "    x = 2",
            "    while x*x <= n:",
            "        if n % x == 0:",
            "            res = res // x * (x-1)",
            "            while n % x == 0:",
            "                n //= x",
            "        x += 1",
            "    if n > 1:",
            "        res = res // n * (n-1)",
            "    return res",
            "",
            "# calculate φ(x) for 1 <= x <= M",
            "M = 10**6",
            "*phi, = range(M+1)",
            "for x in range(2, M+1):",
            "    if phi[x] == x:",
            "        for y in range(x, M+1, x):",
            "            phi[y] = phi[y] // x * (x-1)",
        ],
        "description": "オイラーのファイ関数"
    },
    "Modint": {
        "scope": "python",
        "prefix": "Modint",
        "body": [
            "# https://github.com/wanidon/python-modint/blob/master/modint.py",
            "MOD = 998244353",
            "class ModInt:",
            "",
            "    def __init__(self, x):",
            "        self.x = x.x if isinstance(x, ModInt) else x % MOD",
            "",
            "    __str__ = lambda self:str(self.x)",
            "    __repr__ = __str__",
            "    __int__ = lambda self: self.x",
            "    __index__ = __int__",
            "",
            "    __add__ = lambda self, other: ModInt(self.x + ModInt(other).x)",
            "    __sub__ = lambda self, other: ModInt(self.x - ModInt(other).x)",
            "    __mul__ = lambda self, other: ModInt(self.x * ModInt(other).x)",
            "    __pow__ = lambda self, other: ModInt(pow(self.x, ModInt(other).x, MOD))",
            "    __truediv__ = lambda self, other: ModInt(self.x * pow(ModInt(other).x, MOD - 2, MOD))",
            "    __floordiv__ = lambda self, other: ModInt(self.x // ModInt(other).x)",
            "    __radd__ = lambda self, other: ModInt(other + self.x)",
            "    __rsub__ = lambda self, other: ModInt(other - self.x)",
            "    __rpow__ = lambda self, other: ModInt(pow(other, self.x, MOD))",
            "    __rmul__ = lambda self, other: ModInt(other * self.x)",
            "    __rtruediv__ = lambda self, other: ModInt(other * pow(self.x, MOD - 2, MOD))",
            "    __rfloordiv__ = lambda self, other: ModInt(other // self.x)",
            "",
            "    __lt__ = lambda self, other: self.x < ModInt(other).x",
            "    __gt__ = lambda self, other: self.x > ModInt(other).x",
            "    __le__ = lambda self, other: self.x <= ModInt(other).x",
            "    __ge__ = lambda self, other: self.x >= ModInt(other).x",
            "    __eq__ = lambda self, other: self.x == ModInt(other).x",
            "    __ne__ = lambda self, other: self.x != ModInt(other).x",
        ],
        "description": "Modint"
    },
    "GrayCode": {
        "scope": "python",
        "prefix": "GrayCode",
        "body": [
            "def BinaryToGray(self, n):",
            "    return n^(n>>1)",
            "",
            "def grayToBinary(n):",
            "    res = 0",
            "    while n:",
            "        res ^= n",
            "        n>>=1",
            "    return res",
        ],
        "description": "Grayコード⇔Binaryコード変換"
    },
    "bitlist": {
        "scope": "python",
        "prefix": "bitlist",
        "body": [
            "import itertools",
            "",
            "for bit in itertools.product([True, False], repeat=N):",
            "    su = 0",
            "    for i,b in enumerate(bit):",
            "        if b:",
            "            su += A[i]",
        ],
        "description": "bit全探索"
    },
    "permutationCoeff(nPr)": {
        "scope": "python",
        "prefix": "permutationCoeff(nPr)",
        "body": [
            "def nPr(n, k):",
            "    fact = [0 for _ in range(n + 1)]",
            " ",
            "    # base case",
            "    fact[0] = 1",
            " ",
            "    # Calculate value",
            "    # factorials up to n",
            "    for i in range(1, n + 1):",
            "        fact[i] = i * fact[i - 1]",
            " ",
            "    # P(n, k) = n!/(n-k)!",
            "    return fact[n] // fact[n - k]",
            " ",
        ],
        "description": "順列(nPr)"
    },
    "permutation": {
        "scope": "python",
        "prefix": "permutation",
        "body": [
            "import itertools",
            "",
            "for ptr in itertools.permutations($1, 3):",
        ],
        "description": "順列全探索"
    },
    "permutation_product": {
        "scope": "python",
        "prefix": "permutation_product",
        "body": [
            "import itertools",
            "",
            "for prod in itertools.product($1, repeat=3)",
        ],
        "description": "順列全探索(重複あり) 直積(デカルト積)"
    },
    "combination": {
        "scope": "python",
        "prefix": "combination",
        "body": [
            "import itertools",
            "",
            "for cmb in itertools.combinations($1,3):",
        ],
        "description": "組合せ全探索"
    },	
    "combinations_with_replacement": {
        "scope": "python",
        "prefix": "combinations_with_replacement",
        "body": [
            "import itertools",
            "",
            "for cmb in itertools.combinations_with_replacement($1, 3):",
        ],
        "description": "組合せ全探索(重複あり)"
    },
    "binomialCoeff(nCr)": {
        "scope": "python",
        "prefix": "binomialCoeff(nCr)",
        "body": [
            "def nCr(n, r):",
            "",
            "    res = 1",
            "    for i in range(r):",
            "        res = (res*(n-i))//(i+1)",
            "",
            "    return res",
            "",
        ],
        "description": "組み合わせの通り数(nCr)"
    },
    "combination_with_repetition(nHr)": {
        "scope": "python",
        "prefix": "combination_with_repetition(nHr)",
        "body": [
            "def nHr(n, r):",
            "",
            "    n = n+r-1",
            "    res = 1",
            "    for i in range(r):",
            "        res = (res*(n-i))//(i+1)",
            "",
            "    return res",
            "",
        ],
        "description": "組み合わせ(重複あり)の通り数(nHr)"
    },
    "binomialCoeff(nCr_mod)": {
        "scope": "python",
        "prefix": "binomialCoeff(nCr_mod)",
        "body": [
            "MOD = 10**9 + 7",
            "# xの逆元を求める。フェルマーの小定理より、 x の逆元は x ^ (MOD - 2) に等しい。計算時間はO(log(MOD))程度。",
            "def modinv(x):",
            "    return pow(x,MOD-2,MOD)",
            "",
            "# nCrをMODで割った余りを計算",
            "def nCr(n, r):",
            "    numera = 1  # 分子",
            "    denomi = 1  # 分母",
            "",
            "    for i in range(r):",
            "        numera *= n-i",
            "        numera %= MOD",
            "        denomi *= i+1",
            "        denomi %= MOD",
            "    return numera * modinv(denomi) % MOD",
        ],
        "description": "組み合わせの通り数(nCr)をMODで割った余り"
    },
    "crt": {
        "scope": "python",
        "prefix": "crt",
        "body": [
            "def inv_gcd(a,b):",
            "    a=a%b",
            "    if a==0:",
            "        return (b,0)",
            "    s=b;t=a",
            "    m0=0;m1=1",
            "    while(t):",
            "        u=s//t",
            "        s-=t*u",
            "        m0-=m1*u",
            "        s,t=t,s",
            "        m0,m1=m1,m0",
            "    if m0<0:",
            "        m0+=b//s",
            "    return (s,m0)",
            "",
            "def inv_mod(x,m):",
            "    assert 1<=m",
            "    z=inv_gcd(x,m)",
            "    assert z[0]==1",
            "    return z[1]",
            "",
            "def crt(r,m):",
            "    assert len(r)==len(m)",
            "    n=len(r)",
            "    r0=0;m0=1",
            "    for i in range(n):",
            "        assert 1<=m[i]",
            "        r1=r[i]%m[i]",
            "        m1=m[i]",
            "        if m0<m1:",
            "            r0,r1=r1,r0",
            "            m0,m1=m1,m0",
            "        if (m0%m1==0):",
            "            if (r0%m1!=r1):",
            "                return (0,0)",
            "            continue",
            "        g,im=inv_gcd(m0,m1)",
            "        u1=m1//g",
            "        if ((r1-r0)%g):",
            "            return (0,0)",
            "        x=(r1-r0)//g % u1*im%u1",
            "        r0+=x*m0",
            "        m0*=u1",
            "        if r0<0:",
            "            r0+=m0",
            "    return (r0,m0)",
            " ",
            "T=int(input())",
            "for _ in range(T):",
            "    X,Y,P,Q = map(int, input().split())",
            "    ans = 10**30",
            "    for y in range(Y):",
            "        for q in range(Q):",
            "            C = [2*(X+Y),P+Q]#これで割ったら",
            "            R = [X+y,P+q]#この余りになる対のリスト",
            "            r,m = crt(R,C)",
            "            if m!=0:",
            "                ans = min(ans,r)",
            "    if ans==10**30:",
            "        print('infinity')",
            "    else:",
            "        print(ans)",
        ],
        "description": "中国剰余定理(○で割ったら△になる数字を見つける)"
    },
    "floor_sum": {
        "scope": "python",
        "prefix": "floor_sum",
        "body": [
            "# [0,n)の範囲で、y=a/m*x+b/mの下側(直線上含む)にある格子点の数を求める",
            "def floor_sum(n,m,a,b):",
            "    ans=0",
            "    if a>=m:",
            "        ans+=(n-1)*n*(a//m)//2",
            "        a%=m",
            "    if b>=m:",
            "        ans+=n*(b//m)",
            "        b%=m",
            "    y_max=(a*n+b)//m",
            "    x_max=(y_max*m-b)",
            "    if y_max==0:",
            "        return ans",
            "    ans+=(n-(x_max+a-1)//a)*y_max",
            "    ans+=floor_sum(y_max,a,m,(a-x_max%a)%a)",
            "    return ans",
        ],
        "description": "floor_sum"
    },
    "LIS": {
        "scope": "python",
        "prefix": "LIS",
        "body": [
            "from bisect import bisect",
            "",
            "# N: 数列の長さ",
            "# A[i]: a_i の値",
            "def LIS(N, A):",
            "    INF = 10**10",
            "",
            "    dp = [INF]*(N+1)",
            "    dp[0] = -1",
            "    for a in A:",
            "        #idx = bisect(dp, a) #広義最長増加部分列",
            "        idx = bisect(dp, a-1) ",
            "        dp[idx] = min(a, dp[idx])",
            "    return max(i for i in range(N+1) if dp[i] < INF)",
        ],
        "description": "最長増加部分列（LIS）"
    },
    "rotation_matrix": {
        "scope": "python",
        "prefix": "rotation_matrix",
        "body": [
            "import math",
            "#回転前の座標",
            "x = ",
            "y = ",
            "#回転中心の座標(原点の場合は0)",
            "center_x = ",
            "center_y = ",
            "#回転角度(radian)",
            "angle = math.pi*2",
            "#回転後の座標 ",
            "X = math.cos(angle) * (x - center_x) - math.sin(angle) * (y - center_y) + center_x",
            "Y = math.sin(angle) * (x - center_x) + math.cos(angle) * (y - center_y) + center_y",
        ],
        "description": "回転行列"
    },
    "compress_position": {
        "scope": "python",
        "prefix": "compress_position",
        "body": [
            "def compress(arr):",
            "    *XS, = set(arr)",
            "    XS.sort()",
            "    return {e: i for i, e in enumerate(XS)}",
            "",
            "N =int(input())",
            "A =[int(input()) for _ in range(N)]",
            "B = compress(A)",
            "",
            "for a in A:",
            "    print(B[a])",
        ],
        "description": "座標圧縮"
    },
    "compress_position_2d": {
        "scope": "python",
        "prefix": "compress_position_2d",
        "body": [
            "def compress(arr):",
            "    return {e: i for i, e in enumerate(arr)}",
            "",
            "N = int(input())",
            "rect = []",
            "vals_x, vals_y = set(), set()",
            "for _ in range(N):",
            "    X1,Y1,X2,Y2 = map(int,input().split())",
            "    rect.append([X1,Y1,X2,Y2])",
            "    vals_x |= {X1,X2}",
            "    vals_y |= {Y1,Y2}",
            "vals_x2, vals_y2 = sorted(vals_x), sorted(vals_y)",
            "comp_x, comp_y = compress(vals_x2), compress(vals_y2)",
            "",
            "H,W = len(comp_y), len(comp_x)",
            "A = [[0]*(W+1) for _ in range(H+1)]",
            "for x1,y1,x2,y2 in rect:",
            "    lx,ly,rx,ry = comp_x[x1],comp_y[y1],comp_x[x2],comp_y[y2]",
            "    A[ly][lx] += 1",
            "    A[ry][rx] += 1",
            "    A[ry][lx] -= 1",
            "    A[ly][rx] -= 1",
            "",
            "for y in range(H):",
            "    for x in range(1,W):",
            "        A[y][x] += A[y][x-1]",
            "",
            "for y in range(1,H):",
            "    for x in range(W):",
            "        A[y][x] += A[y-1][x]",
            "",
            "ans = 0",
            "for y in range(H):",
            "    for x in range(W):",
            "        if A[y][x]:",
            "            ans += (vals_x2[x+1] - vals_x2[x]) * (vals_y2[y+1] - vals_y2[y])",
            "",
            "print(ans)",
            "",
        ],
        "description": "二次元座標圧縮"
    },
    "counter": {
        "scope": "python",
        "prefix": "counter",
        "body": [
            "from collections import Counter",
            "count = Counter($1)",
        ],
        "description": "数え上げ"
    },
    "defaultdict": {
        "scope": "python",
        "prefix": "defaultdict",
        "body": [
            "from collections import defaultdict",
            "dict = defaultdict(int)",
        ],
        "description": "defaultdict"
    },
    "alphabet": {
        "scope": "python",
        "prefix": "alphabet",
        "body": [
            "alphabet = dict.fromkeys(\"abcdefghijklmnopqrstuvwxyz\",0)",
        ],
        "description": "アルファベットの辞書"
    },
    "chr_and_ord": {
        "scope": "python",
        "prefix": "chr_and_ord",
        "body": [
            "# 0-indexed",
            "def int_to_lower(k):",
            "    return chr(k+97)",
            "",
            "def int_to_upper(k):",
            "    return chr(k+65)",
            "",
            "def lower_to_int(c):",
            "    return ord(c)-97",
            "",
            "def upper_to_int(c):",
            "    return ord(c)-65",
        ],
        "description": "k番目のアルファベットcを相互変換"
    },
    "rolling": {
        "scope": "python",
        "prefix": "rolling",
        "body": [
            "def rolling(s, n):",
            "    l = len(s)",
            "    #右にシフトの場合",
            "    return s[-n%l:] + s[:-n%l] #左にシフトの場合はnの正負を逆に",
        ],
        "description": "文字列sをn文字分右に回転"
    },
    "regular_expression": {
        "scope": "python",
        "prefix": "regular_expression",
        "body": [
            "import re",
            "s = \"testtestest\"",
            "p = re.compile('test')",
            "hit = p.match(s)",
            "find = p.findall(s) # ['test', 'test']",
        ],
        "description": "正規表現"
    },
    "LCS": {
        "scope": "python",
        "prefix": "LCS",
        "body": [
            "def lcs(S, T):",
            "    L1,L2 = len(S),len(T)",
            "    dp = [[0]*(L2+1) for i in range(L1+1)]",
            " ",
            "    for i in reversed(range(L1)):",
            "        for j in reversed(range(L2)):",
            "            r = max(dp[i][j+1], dp[i+1][j])",
            "            if S[i] == T[j]:",
            "                r = max(r, dp[i+1][j+1] + 1)",
            "            dp[i][j] = r",
            "",
            "    return dp[0][0] #最長共通部分列の長さ",
            "",
            "    # 復元処理",
            "    res = []",
            "    i,j = 0,0",
            "    while i < N and j < M:",
            "        if S[i] == T[j]:",
            "            res.append(S[i])",
            "            i += 1; j += 1",
            "        elif dp[i][j] == dp[i+1][j]:",
            "            i += 1",
            "        elif dp[i][j] == dp[i][j+1]:",
            "            j += 1",
            "    return \"\".join(res)",
            "",
            "Q =int(input())",
            "for _ in range(Q):",
            "    S = input()",
            "    T = input()",
            "    print(lcs(S,T))",
        ],
        "description": "LCS(最長共通部分列)"
    },
    "LCS_COUNT": {
        "scope": "python",
        "prefix": "LCS_COUNT",
        "body": [
            "def lcs_count(S, T):",
            "    L1 = len(S)",
            "    L2 = len(T)",
            "    dp = [[0]*(L2+2) for i in range(L1+2)]",
            "    sdp = [[0]*(L2+2) for i in range(L1+2)]",
            "    dp[0][0] = 1",
            "    sdp[1][1] = 1",
            " ",
            "    for i in range(L1+1):",
            "        for j in range(L2+1):",
            "            if i == 0 and j == 0:",
            "                continue",
            "            if i-1 >= 0 and j-1 >= 0 and S[i-1] == T[j-1]:",
            "                dp[i][j] = sdp[i][j]",
            "            sdp[i+1][j+1] = (sdp[i+1][j] + sdp[i][j+1] - sdp[i][j] + dp[i][j]) % (10**9+7)",
            "",
            "    # sdp[L1+1][L2+1] が部分文字列の個数",
            "    return sdp[L1+1][L2+1]",
        ],
        "description": "CS(共通部分列)の個数カウント"
    },
    "RollingHash": {
        "scope": "python",
        "prefix": "RollingHash",
        "body": [
            "from random import randrange",
            "MOD = (1 << 61) - 1",
            "BASE = randrange(2, MOD - 1) # Hash衝突攻撃対策",
            "class RollingHash():",
            "    def __init__(self, s):",
            "        self.mod = MOD",
            "        self.base = BASE",
            "        self.pw = pw = [1] * (len(s) + 1)",
            "",
            "        l = len(s)",
            "        self.h = h = [0]*(l+1)",
            "",
            "        v = 0",
            "        for i in range(l):",
            "            h[i+1] = v = (v * self.base + ord(s[i])) % self.mod",
            "        v = 1",
            "        for i in range(l):",
            "            pw[i+1] = v = v * self.base % self.mod",
            "    def get(self, l, r):",
            "        return (self.h[r] - self.h[l] * self.pw[r-l]) % self.mod",
            "",
            "# SがTの中に存在するかを判定したいとする",
            "S = input()",
            "T = input()",
            "",
            "# SとTの[0:1][0:2]...[0:len]のハッシュ値を計算",
            "Roll_S = RollingHash(S)",
            "Roll_T = RollingHash(T)",
            "",
            "# Tの先頭から順に、Sと一致する箇所があるかを判定",
            "for i in range(len(T)-len(S)+1):",
            "    # O(1)で判定",
            "    if Roll_S.get(0,len(S)) == Roll_T.get(i,i+len(S)):",
            "        print(\"Yes\")",
            "        exit()",
            "print(\"No\")",
        ],
        "description": "ローリングハッシュ"
    },
    "bisect": {
        "scope": "python",
        "prefix": "bisect",
        "body": [
            "from bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right",
            "'''",
            "bisect(A,x) #ソートされたリストAにソートを崩さずに値xを挿入するとき、xの入るべきインデックスを返す。",
            "bisect_left(A,x) #リストAに値xを入れ、xが複数になるとき、一番左の値xのインデックスを返す。",
            "bisect_right(A,x) #リストAに値xを入れ、xが複数になるとき、一番右の値xのインデックスを返す(bisect.bisectと同じ)。",
            "insort(A,x) #リストAに含まれるxのうち、どのエントリーよりも後ろにxをO(N)で挿入する。",
            "'''",
        ],
        "description": "二分探索"
    },
    "meguru_bisect": {
        "scope": "python",
        "prefix": "meguru_bisect",
        "body": [
            "def is_ok(arg):",
            "    # 条件を満たすかどうか？問題ごとに定義",
            "    pass",
            "",
            "def meguru_bisect(ng, ok):",
            "    '''",
            "    初期値のng,okを受け取り,is_okを満たす最小(最大)のokを返す",
            "    まずis_okを定義すべし",
            "    ng ok は  とり得る最小の値-1 とり得る最大の値+1",
            "    最大最小が逆の場合はよしなにひっくり返す",
            "    '''",
            "    while (abs(ok - ng) > 1):",
            "        mid = (ok + ng) // 2",
            "        if is_ok(mid):",
            "            ok = mid",
            "        else:",
            "            ng = mid",
            "    return ok",
        ],
        "description": "めぐる式二分探索"
    },
    "Dijkstra": {
        "scope": "python",
        "prefix": "Dijkstra",
        "body": [
            "from heapq import heappush, heappop",
            "INF=10**18",
            "def dijkstra(d,p,s):",
            "    hq = [(0, s)] # (distance, node)",
            "    while hq:",
            "        cost,v = heappop(hq) # ノードを pop する",
            "        if dist[v] < cost:",
            "            continue",
            "        for to, cost in adj[v]: # ノード v に隣接しているノードに対して",
            "            if d[v] + cost < d[to]:",
            "                d[to] = d[v] + cost",
            "                heappush(hq, (d[to], to))",
            "                p[to] = v",
            "    return dist",
            "",
            "#s→tの最短経路復元",
            "def get_path(t):",
            "    if dist[t] == INF:",
            "        return []",
            "    path = []",
            "    while t != -1:",
            "        path.append(t)",
            "        t = prev[t]",
            "    #t->sの順になっているので逆順にする",
            "    path.reverse()",
            "    return path",
            "",
            "# 入力の受け取り・隣接リストadjの構築：",
            "N,M = map(int, input().split()) # ノード数, エッジ数",
            "adj = [[] for _ in range(N)]",
            "for _ in range(M):",
            "    s,t,d = map(int, input().split())",
            "    s,t = s-1,t-1",
            "    adj[s].append((t, d))",
            "",
            "dist = [INF]*N",
            "dist[0] = 0",
            "prev = [-1]*N",
            "dijkstra(dist,prev,0)",
        ],
        "description": "ダイクストラ法：2点間の最短路をO(ElogV)で求める(負経路はNG)"
    },
    "Bellman_Ford": {
        "scope": "python",
        "prefix": "Bellman_Ford",
        "body": [
            "inf=float(\"inf\")",
            "def bellman_ford(s,n):",
            "    dist = [inf] * n",
            "    dist[s]=0",
            "    for i in range(n):",
            "        for edge in edges:",
            "            if dist[edge[1]] > dist[edge[0]] + edge[2]:",
            "                dist[edge[1]] = dist[edge[0]] + edge[2]",
            "                if i==n-1: return -1",
            "    return dist",
            "",
            "v,e,r = map(int, input().split())",
            "edges = []",
            "for i in range(e):",
            "    s, t, d = map(int, input().split())",
            "    edges.append((s, t, d))",
            "",
            "dist = bellman_ford(r,v)",
        ],
        "description": "ベルマンフォード法：２点間の最短路をO(EV)で見つける(負経路もOK)"
    },
    "Warshall_Floyd": {
        "scope": "python",
        "prefix": "Warshall_Floyd",
        "body": [
            "#d[i][j]は2頂点間i, j間の移動コストを格納, Vは頂点数",
            "INF = 10**18",
            "def Warshall_Floyd(d,nxt,n):",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                if d[i][k]!=INF and d[k][j]!=INF:",
            "                    if d[i][k] + d[k][j] < d[i][j]:",
            "                        d[i][j] = d[i][k] + d[k][j]",
            "                        nxt[i][j] = nxt[i][k]",
            "                    elif k != i and d[i][k] + d[k][j] == d[i][j]:",
            "                        nxt[i][j] = min(nxt[i][j], nxt[i][k]) #辞書順最小化",
            "",
            "#s→tの最短経路復元",
            "def get_path(s,t):",
            "    if dist[s][t] == INF:",
            "        return []",
            "    path = [s]",
            "    curr = s",
            "    while curr != t:",
            "        curr = nxt[curr][t]",
            "        path.append(curr)",
            "    return path",
            "",
            "#隣接行列で経路を格納",
            "N,M = map(int, input().split())",
            "dist = [[INF]*N for _ in range(N)]",
            "for i in range(M):",
            "    s,t,d = map(int, input().split())",
            "    s,t = s-1,t-1",
            "    dist[s][t] = d",
            "",
            "#s,tが同じ場合は距離0",
            "for i in range(N):",
            "    dist[i][i] = 0",
            "",
            "#経路復元用",
            "nxt = [[0]*N for _ in range(N)]",
            "for i in range(N):",
            "    for j in range(N):",
            "        nxt[i][j] = j",
            "",
            "Warshall_Floyd(dist,nxt,N)",
            "",
            "#負経路の有無チェック",
            "for i in range(N):",
            "    if dist[i][i] < 0:",
            "        print(\"NEGATIVE CYCLE\")",
            "        exit()",
            "",
            "#全点対間距離の出力",
            "for i in range(N):",
            "    for j in range(N):",
            "        if dist[i][j] == INF:",
            "            dist[i][j] = \"INF\"",
            "    print(*dist[i])",
            "",
        ],
        "description": "ワーシャルフロイド法：グラフの全ての頂点の間の最短路をO(V^3)で見つける(負経路もOK)"
    },
    "Union-Find": {
        "scope": "python",
        "prefix": "Union-Find",
        "body": [
            "from collections import defaultdict",
            "",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1]*n",
            "",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        self.parents[x] = self.find(self.parents[x])",
            "        return self.parents[x]",
            "",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "",
            "        if x == y:",
            "            return",
            "",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "",
            "    def group_count(self):",
            "        return len(self.roots())",
            "",
            "    def all_group_members(self):",
            "        group_members = defaultdict(list)",
            "        for member in range(self.n):",
            "            group_members[self.find(member)].append(member)",
            "        return group_members",
            "",
            "    def __str__(self):",
            "        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())",
            "'''",
            "uf = UnionFind(N) -> create 6 separated nodes",
            "uf.union(0, 2) -> unite two ids",
            "uf.same(0, 2) -> have same top node?",
            "uf.find(0) -> id of top node",
            "uf.size(5) -> num of group",
            "",
            "# 文字列や任意の数字を要素にしたり復元したい場合",
            "l = ['A', 'B', 'C', 'D', 'E']",
            "",
            "# {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}",
            "d = {x: i for i, x in enumerate(l)}",
            "",
            "# {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E'}",
            "d_inv = {i: x for i, x in enumerate(l)}",
            "",
            "uf.union(d['A'], d['D'])",
            "print(d_inv[uf.find(d['D'])])",
            "# A",
            "'''",
        ],
        "description": "Union-Find"
    },
    "WeightedUnion-Find": {
        "scope": "python",
        "prefix": "WeightedUnion-Find",
        "body": [
            "# 重み付きUnionFind",
            "class WeightedUnionFind:",
            "    def __init__(self, n):",
            "        self.parents = [i for i in range(n)] # 親",
            "        self.rank = [0]*n # 木の深さ",
            "        self.weights = [0]*n # 重み",
            "",
            "    # xの根を探索",
            "    def find(self, x):",
            "        if self.parents[x] == x:",
            "            return x",
            "        root = self.find(self.parents[x])",
            "        self.weights[x] += self.weights[self.parents[x]]",
            "        self.parents[x] = root",
            "        return root",
            "",
            "    # xからyへの重みをweightとして統合",
            "    def union(self, x, y, weight=0):",
            "        root_x, root_y = self.find(x), self.find(y)",
            "        if root_x == root_y:",
            "            return",
            "        if self.rank[root_x] < self.rank[root_y]:",
            "            self.parents[root_x] = root_y",
            "            self.weights[root_x] = weight - self.weights[x] + self.weights[y]",
            "        else:",
            "            self.parents[root_y] = root_x",
            "            self.weights[root_y] = -weight - self.weights[y] + self.weights[x]",
            "            if self.rank[root_x] == self.rank[root_y]:",
            "                self.rank[root_x] += 1",
            "",
            "    # xとyが同じグループか",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "    # xからyへのコスト",
            "    def diff(self, x, y):",
            "        return self.weights[x] - self.weights[y]",
            "",
            "'''",
            "wuf = WeightedUnionFind(N) -> create N separated nodes",
            "wuf.union(0, 2, 5) -> unite two ids with weight=5 from 0 to 2",
            "wuf.same(0, 2) -> have same top node?",
            "wuf.find(0) -> id of top node",
            "",
            "# 文字列や任意の数字を要素にしたり復元したい場合",
            "l = ['A', 'B', 'C', 'D', 'E']",
            "",
            "# {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}",
            "d = {x: i for i, x in enumerate(l)}",
            "",
            "# {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E'}",
            "d_inv = {i: x for i, x in enumerate(l)}",
            "",
            "wuf.union(d['A'], d['D'], weight)",
            "print(d_inv[uf.find(d['D'])])",
            "# A",
            "'''",
        ],
        "description": "重み付きUnion-Find"
    },
    "Kruskal": {
        "scope": "python",
        "prefix": "Kruskal",
        "body": [
            "#union-find木",
            "class UnionFind():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1]*n",
            "",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        self.parents[x] = self.find(self.parents[x])",
            "        return self.parents[x]",
            "",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "",
            "        if x == y:",
            "            return",
            "",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "#クラスカル法",
            "# V: 頂点集合(リスト) E: 辺集合[始点, 終点, 重み](リスト)",
            "class kruskal():",
            "    def __init__(self, V, E):",
            "        self.V = V",
            "        self.E = E",
            "        self.E.sort(key=lambda x: x[2]) #辺の重みでソート",
            "",
            "    def weight(self): #最小全域木の重み和と選択された頂点を求める",
            "        UF = UnionFind(len(self.V)) #頂点数でUnion Find Treeを初期化",
            "        weight = 0",
            "        nodes = set()",
            "        for i in range(len(self.E)):",
            "            s,t,w = self.E[i]",
            "            if not UF.same(s,t):",
            "                UF.union(s,t)",
            "                weight += w",
            "                nodes.add(s)",
            "                nodes.add(t)",
            "",
            "        return weight, sorted(list(nodes))",
            "",
            "N,M = map(int, input().split())",
            "",
            "nodes = [0]*N # Vの要素数Nだけを使用",
            "edges = []",
            "for _ in range(M):",
            "    s,t,w = map(int, input().split())",
            "    edges.append((s,t,w))",
            "",
            "mst = kruskal(nodes,edges)",
            "print(mst.weight()[0])",
            "",
        ],
        "description": "最小全域木の辺の重みの総和の算出"
    },
    "BalancingTree": {
        "scope": "python",
        "prefix": "BalancingTree(AVLTree, OrderedSet)",
        "body": [
            "# 平衡二分木(AVL木)",
            "class BalancingTree:",
            "    def __init__(self, n):",
            "        self.N = n",
            "        self.root = self.node(1<<n, 1<<n)",
            "",
            "    def append(self, v):# v を追加（その時点で v はない前提）",
            "        v += 1",
            "        nd = self.root",
            "        while True:",
            "            if v == nd.value:",
            "                # v がすでに存在する場合に何か処理が必要ならここに書く",
            "                return 0",
            "            else:",
            "                mi, ma = min(v, nd.value), max(v, nd.value)",
            "                if mi < nd.pivot:",
            "                    nd.value = ma",
            "                    if nd.left:",
            "                        nd = nd.left",
            "                        v = mi",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.left = self.node(mi, p - (p&-p)//2)",
            "                        break",
            "                else:",
            "                    nd.value = mi",
            "                    if nd.right:",
            "                        nd = nd.right",
            "                        v = ma",
            "                    else:",
            "                        p = nd.pivot",
            "                        nd.right = self.node(ma, p + (p&-p)//2)",
            "                        break",
            "",
            "    def leftmost(self, nd):",
            "        if nd.left: return self.leftmost(nd.left)",
            "        return nd",
            "",
            "    def rightmost(self, nd):",
            "        if nd.right: return self.rightmost(nd.right)",
            "        return nd",
            "",
            "    def find_l(self, v): # vより真に小さいやつの中での最大値（なければ-1）",
            "        v += 1",
            "        nd = self.root",
            "        prev = 0",
            "        if nd.value < v: prev = nd.value",
            "        while True:",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                prev = nd.value",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "",
            "    def find_r(self, v): # vより真に大きいやつの中での最小値（なければRoot）",
            "        v += 1",
            "        nd = self.root",
            "        prev = 0",
            "        if nd.value > v: prev = nd.value",
            "        while True:",
            "            if v < nd.value:",
            "                prev = nd.value",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    return prev - 1",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    return prev - 1",
            "",
            "    @property",
            "    def max(self):",
            "        return self.find_l((1<<self.N)-1)",
            "",
            "    @property",
            "    def min(self):",
            "        return self.find_r(-1)",
            "",
            "    def delete(self, v, nd = None, prev = None): # 値がvのノードがあれば削除（なければ何もしない）",
            "        v += 1",
            "        if not nd: nd = self.root",
            "        if not prev: prev = nd",
            "        while v != nd.value:",
            "            prev = nd",
            "            if v <= nd.value:",
            "                if nd.left:",
            "                    nd = nd.left",
            "                else:",
            "                    #####",
            "                    return",
            "            else:",
            "                if nd.right:",
            "                    nd = nd.right",
            "                else:",
            "                    #####",
            "                    return",
            "        if (not nd.left) and (not nd.right):",
            "            if not prev.left:",
            "                prev.right = None",
            "            elif not prev.right:",
            "                prev.left = None",
            "            else:",
            "                if nd.pivot == prev.left.pivot:",
            "                    prev.left = None",
            "                else:",
            "                    prev.right = None",
            "",
            "        elif nd.right:",
            "            # print(\"type A\", v)",
            "            nd.value = self.leftmost(nd.right).value",
            "            self.delete(nd.value - 1, nd.right, nd)    ",
            "        else:",
            "            # print(\"type B\", v)",
            "            nd.value = self.rightmost(nd.left).value",
            "            self.delete(nd.value - 1, nd.left, nd)",
            "",
            "    def __contains__(self, v: int) -> bool:",
            "        return self.find_r(v - 1) == v",
            "",
            "    class node:",
            "        def __init__(self, v, p):",
            "            self.value = v",
            "            self.pivot = p",
            "            self.left = None",
            "            self.right = None",
            "",
            "    def debug(self):",
            "        def debug_info(nd_):",
            "            return (nd_.value - 1, nd_.pivot - 1, nd_.left.value - 1 if nd_.left else -1, nd_.right.value - 1 if nd_.right else -1)",
            "",
            "        def debug_node(nd):",
            "            re = []",
            "            if nd.left:",
            "                re += debug_node(nd.left)",
            "            if nd.value: re.append(debug_info(nd))",
            "            if nd.right:",
            "                re += debug_node(nd.right)",
            "            return re",
            "        print(\"Debug - root =\", self.root.value - 1, debug_node(self.root)[:50])",
            "",
            "    def debug_list(self):",
            "        def debug_node(nd):",
            "            re = []",
            "            if nd.left:",
            "                re += debug_node(nd.left)",
            "            if nd.value: re.append(nd.value - 1)",
            "            if nd.right:",
            "                re += debug_node(nd.right)",
            "            return re",
            "        return debug_node(self.root)[:-1]",
            "",
            "'''",
            "BT = BalancingTree(n) # 0~2^nまでの値を持つ要素を入れられるピボット木 2^17≒10^5, 2^20≒10^6, 2^30≒10^9",
            "BT.append(3) # 要素の挿入",
            "BT.delete(20) # 要素の削除",
            "BT.find_l(12) # 要素より真に小さいやつの中での最大値（なければ-1）",
            "BT.find_r(5) # 要素より真に大きいやつの中での最小値（なければRoot）",
            "BT.min # 格納要素中の最小値",
            "BT.max # 格納要素中の最大値",
            "3 in BT # 格納要素中の存在判定",
            "print(BT.debug_list()) # 格納された要素一覧の出力",
            "'''",
        ],
        "description": "平衡二分木(AVL木)"
    },
    "Chu_Liu_Edmonds": {
        "scope": "python",
        "prefix": "Chu_Liu_Edmonds",
        "body": [
            "from heapq import heappush, heappop",
            "def chu_liu_edmonds(v,edges,r):",
            "    if v <= 1:",
            "        return 0",
            "    q = [[] for _ in range(0, v)]",
            "    for s, t, w in edges:",
            "        heappush(q[t], (w, s))",
            "    M = [(0, -1) for _ in range(0, v)]",
            "    for t in range(0, v):",
            "        if t != r:",
            "            w, s = heappop(q[t])",
            "            M[t] = (w, s)",
            "    ",
            "    used = [False for _ in range(0, v)]",
            "    hist = []",
            "    cycle = []",
            "    for t in range(0, v):",
            "        w, s = M[t]",
            "        if s == -1 or used[t] == True:",
            "            continue",
            "        if used[t] == False:",
            "            used[t] = True",
            "            hist += [t]",
            "            tt = s",
            "            while used[tt] == False:",
            "                used[tt] = True",
            "                hist += [tt]",
            "                w, s = M[tt]",
            "                if s == -1:",
            "                    hist = []",
            "                    break",
            "                tt = s",
            "            if used[tt] == True and s != -1 and 0 < len(hist):",
            "                try:",
            "                    k = hist.index(tt)",
            "                    cycle = hist[k:]",
            "                except:",
            "                    continue",
            "                finally:",
            "                    pass",
            "                break",
            "                ",
            "    if len(cycle) == 0:",
            "        return sum(m[0] for m in M)",
            "",
            "    parent = min(cycle)",
            "    rn = [0 for _ in range(0, v)]",
            "    k = 0",
            "    for t in range(0, v):",
            "        if k == parent:",
            "            k += 1",
            "        if t in cycle:",
            "            rn[t] = parent",
            "        else:",
            "            rn[t] = k",
            "            k += 1",
            "            ",
            "    Vp = v - len(cycle) + 1",
            "    Ep = []",
            "    for s, t, w in edges:",
            "        if s in cycle:",
            "            if t in cycle:",
            "                continue",
            "            else:",
            "                Ep += [[parent, rn[t], w]]",
            "        else:",
            "            if t in cycle:",
            "                Ep += [[rn[s], parent, w - M[t][0]]]",
            "            else:",
            "                Ep += [[rn[s], rn[t], w]]",
            "    r = rn[r]",
            "    return chu_liu_edmonds(Vp, Ep, r) + sum(M[t][0] for t in cycle)",
            "",
            "v,e,r = map(int, input().split())",
            "edges = []",
            "for _ in range(e):",
            "    s, t, w = map(int, input().split())",
            "    edges.append((s, t, w))",
            "",
            "print(chu_liu_edmonds(v, edges, r))",
        ],
        "description": "#最小全域有向木の辺の重みの総和を求める"
    },
    "tree_diameter": {
        "scope": "python",
        "prefix": "tree_diameter",
        "body": [
            "# N: 木Tの頂点数",
            "# graph[u] = [(w, c), ...]:",
            "#   頂点uに隣接する頂点wとそれを繋ぐ辺の長さc",
            "from collections import deque",
            "def tree_diameter(s):",
            "    dist = [None]*N",
            "    que = deque([s])",
            "    dist[s] = 0",
            "    while que:",
            "        v = que.popleft()",
            "        d = dist[v]",
            "        for w, c in graph[v]:",
            "            if dist[w] is not None:",
            "                continue",
            "            dist[w] = d + c",
            "            que.append(w)",
            "    d = max(dist)",
            "    return dist.index(d), d",
            "",
            "u, _ = tree_diameter(0)",
            "v, d = tree_diameter(u)",
            "# パスu-vがこの木Tの直径(長さd)",
        ],
        "description": "木の直径"
    },
    "LCA": {
        "scope": "python",
        "prefix": "LCA",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "class LCA:",
            "    \"\"\"",
            "    links[v] = { (u, w), (u, w), ... }  (u:隣接頂点, w:辺の重み)",
            "    というグラフ情報から、ダブリングによるLCAを構築。",
            "    任意の2頂点のLCAおよび距離を取得できるようにする",
            "    \"\"\"",
            " ",
            "    def __init__(self, n, links, root=0):",
            "        self.depths = [-1] * n",
            "        self.distances = [-1] * n",
            "        prev_ancestors = self._init_dfs(n, links, root)",
            "        self.ancestors = [prev_ancestors]",
            "        max_depth = max(self.depths)",
            "        d = 1",
            "        while d < max_depth:",
            "            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]",
            "            self.ancestors.append(next_ancestors)",
            "            d <<= 1",
            "            prev_ancestors = next_ancestors",
            " ",
            "    def _init_dfs(self, n, links, root):",
            "        q = [(root, -1, 0, 0)]",
            "        direct_ancestors = [-1] * (n + 1)  # 頂点数より1個長くし、存在しないことを-1で表す。末尾(-1)要素は常に-1",
            "        while q:",
            "            v, p, dep, dist = q.pop()",
            "            direct_ancestors[v] = p",
            "            self.depths[v] = dep",
            "            self.distances[v] = dist",
            "            q.extend((u, v, dep + 1, dist + w) for u, w in links[v] if u != p)",
            "        return direct_ancestors",
            " ",
            "    def get_lca(self, u, v):",
            "        du, dv = self.depths[u], self.depths[v]",
            "        if du > dv:",
            "            u, v = v, u",
            "            du, dv = dv, du",
            "        tu = u",
            "        tv = self.upstream(v, dv - du)",
            "        if u == tv:",
            "            return u",
            "        for k in range(du.bit_length() - 1, -1, -1):",
            "            mu = self.ancestors[k][tu]",
            "            mv = self.ancestors[k][tv]",
            "            if mu != mv:",
            "                tu = mu",
            "                tv = mv",
            "        lca = self.ancestors[0][tu]",
            "        assert lca == self.ancestors[0][tv]",
            "        return lca",
            " ",
            "    def get_distance(self, u, v):",
            "        lca = self.get_lca(u, v)",
            "        return self.distances[u] + self.distances[v] - 2 * self.distances[lca]",
            " ",
            "    def upstream(self, v, k):",
            "        i = 0",
            "        while k:",
            "            if k & 1:",
            "                v = self.ancestors[i][v]",
            "            k >>= 1",
            "            i += 1",
            "        return v",
            "",
            "N = int(input())",
            "graph = [[] for _ in range(N)]",
            "for _ in range(N-1):",
            "    a,b =map(int,input().split())",
            "    a,b = a-1,b-1",
            "    graph[a].append((b,1))",
            "    graph[b].append((a,1))",
            "",
            "lca = LCA(N,graph)",
        ],
        "description": "LCA(最小共通祖先)"
    },
    "LowLink": {
        "scope": "python",
        "prefix": "LowLink",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def get_articulation_points(adj, n, start=0):",
            "    order = [None]*n",
            "    result = []; count = 0",
            "    def dfs(v, prev):",
            "        nonlocal count",
            "        r_min = order[v] = count # 到達時にラベル",
            "        fcnt = 0; p_art = 0",
            "        count += 1",
            "        for w in adj[v]:",
            "            if w == prev:",
            "                continue",
            "            if order[w] is None:",
            "                ret = dfs(w, v)",
            "                # 子の頂点が到達できたのが、自身のラベル以上の頂点のみ",
            "                # => 頂点vは関節点",
            "                p_art |= (order[v] <= ret)",
            "                r_min = min(r_min, ret)",
            "                fcnt += 1",
            "            else:",
            "                r_min = min(r_min, order[w])",
            "        p_art |= (r_min == order[v] and len(adj[v]) > 1)",
            "        if (prev == -1 and fcnt > 1) or (prev != -1 and p_art):",
            "            # 頂点startの場合は、二箇所以上の子頂点を調べたら自身は関節点",
            "            result.append(v)",
            "        return r_min",
            "    dfs(start, -1)",
            "    return result",
            "",
            "v,e = map(int, input().split())",
            "adj = [[] for i in range(v)]",
            "for _ in range(e):",
            "    s, t = map(int, input().split())",
            "    adj[s].append(t)",
            "    adj[t].append(s)",
            "    ",
            "ans = sorted(get_articulation_points(adj, v, start=0))",
        ],
        "description": "無向グラフの関節点(Articulation Points)の算出"
    },
    "Bridge": {
        "scope": "python",
        "prefix": "Bridge",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**6)",
            "def bridge(adj, n):",
            "    result = set()",
            "    label = [None]*n",
            "    gen = 0",
            "    cost = [0]*n",
            "    def dfs(u, p):",
            "        nonlocal gen",
            "        res = 0",
            "        for v in adj[u]:",
            "            if v == p:",
            "                continue",
            "            if label[v] is not None:",
            "                if label[v] < label[u]:",
            "                    cost[v] += 1",
            "                    res += 1",
            "            else:",
            "                label[v] = gen; gen += 1",
            "                r = dfs(v, u)",
            "                if r == 0:",
            "                    result.add((u, v) if u < v else (v, u))",
            "                res += r",
            "        res -= cost[u]",
            "        return res",
            "    for v in range(n):",
            "        if not label[v]:",
            "            label[v] = gen; gen += 1",
            "            r = dfs(v, -1)",
            "            assert r == 0, r",
            "    return result",
            "",
            "v,e = map(int, input().split())",
            "adj = [[] for i in range(v)]",
            "for _ in range(e):",
            "    s, t = map(int, input().split())",
            "    adj[s].append(t)",
            "    adj[t].append(s)",
            "    ",
            "ans = sorted(bridge(adj, v))",
        ],
        "description": "グラフの橋(除去するとグラフが連結でなくなる辺)を検出"
    },
    "SCC": {
        "scope": "python",
        "prefix": "SCC",
        "body": [
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "# 強連結成分分解(SCC): グラフGに対するSCCを行う",
            "# 入力: <N>: 頂点サイズ, <G>: 順方向の有向グラフ, <RG>: 逆方向の有向グラフ",
            "# 出力: num_group:ラベル数, group:各頂点のラベル番号",
            "def scc(N, G, RG):",
            "    order = []",
            "    used = [0]*N",
            "    group = [None]*N",
            "    def dfs(s):",
            "        used[s] = 1",
            "        for t in G[s]:",
            "            if not used[t]:",
            "                dfs(t)",
            "        order.append(s)",
            "    def rdfs(s, col):",
            "        group[s] = col",
            "        used[s] = 1",
            "        for t in RG[s]:",
            "            if not used[t]:",
            "                rdfs(t, col)",
            "    for i in range(N):",
            "        if not used[i]:",
            "            dfs(i)",
            "    used = [0]*N",
            "    num_group = 0",
            "    for s in reversed(order):",
            "        if not used[s]:",
            "            rdfs(s, num_group)",
            "            num_group += 1",
            "    return num_group, group",
            "",
            "# 縮約後のグラフを構築",
            "def construct(N, G, label, group):",
            "    G0 = [set() for i in range(label)]",
            "    GP = [[] for i in range(label)]",
            "    for v in range(N):",
            "        lbs = group[v]",
            "        for w in G[v]:",
            "            lbt = group[w]",
            "            if lbs == lbt:",
            "                continue",
            "            G0[lbs].add(lbt)",
            "        GP[lbs].append(v)",
            "    return G0, GP",
            "",
            "N = int(input())",
            "X = list(map(int,input().split()))",
            "",
            "graph = [[] for _ in range(N)]",
            "rgraph = [[] for _ in range(N)]",
            "for i in range(N):",
            "    X[i] -= 1",
            "    graph[i].append(X[i])",
            "    rgraph[X[i]].append(i)",
            "",
            "num_group,group = scc(N,graph,rgraph)",
            "G0,GP = construct(N,G,num_group,group)",
            "",
        ],
        "description": "SCC(強連結成分分解)"
    },
    "dfs_islands": {
        "scope": "python",
        "prefix": "dfs_islands",
        "body": [
            "# Pythonで提出!!",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "#move = ([1, 0], [-1, 0], [0, 1], [0, -1]) #縦横移動",
            "move = ([-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]) #縦横斜め移動",
            "def dfs(y,x):",
            "    seen[y][x] = True",
            "    for dy, dx in move:",
            "        ny,nx = y+dy,x+dx",
            "        if 0 <= ny < H and 0 <= nx < W and seen[ny][nx] == False and C[ny][nx] == 1:",
            "            dfs(ny,nx)",
            "",
            "H,W = map(int,input().split())",
            "C =[list(map(int,input().split())) for _ in range(H)]",
            "seen = [[False]*W for _ in range(H)]",
            "",
            "ans = 0",
            "for h in range(H):",
            "    for w in range(W):",
            "        if seen[h][w] == False and C[h][w] == 1:",
            "            ans += 1",
            "            dfs(h,w)",
            "",
            "print(ans)",
        ],
        "description": "DFS(グリッド地図の探索)"
    },
    "dfs_timestamp": {
        "scope": "python",
        "prefix": "dfs_timestamp",
        "body": [
            "# Pythonで提出!!",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "# 連結でないグラフの場合は、未発見の頂点が無くなるまでdfsを繰り返す必要あり",
            "# コメントアウト箇所を有効化するとオイラーツアー可能",
            "def dfs(s):",
            "    global cnt",
            "",
            "    # 行きがけ",
            "    cnt += 1",
            "    stamp[s][0] = cnt",
            "    # euler.append(s+1)",
            "",
            "    seen[s] = True",
            "    for to in graph[s]:",
            "        if seen[to]:",
            "            continue",
            "        dfs(to)",
            "        # euler.append(s+1)",
            "",
            "    # 帰りがけ",
            "    cnt += 1",
            "    stamp[s][1] = cnt",
            "",
            "N = int(input())",
            "graph = [[] for _ in range(N)]",
            "for _ in range(N-1):",
            "    a,b =map(int,input().split())",
            "    a,b = a-1,b-1",
            "    graph[a].append(b)",
            "    graph[b].append(a)",
            "",
            "for i in range(N):",
            "    graph[i].sort()",
            "",
            "stamp = [[0,0] for _ in range(N)]",
            "seen = [False]*N",
            "cnt = 0",
            "euler = []",
            "dfs(0)",
            "print(*euler)",
        ],
        "description": "行きがけ/帰りがけのタイムスタンプを取得するDFS(オイラーツアーも可能)"
    },
    "dfs_treeTraversal": {
        "scope": "python",
        "prefix": "dfs_treeTraversal",
        "body": [
            "# Pythonで提出!!",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "class Node:",
            "    def __init__(self, val):",
            "        self.val = val",
            "        self.next = None",
            "        self.prev = None",
            "",
            "# 行きがけ/通りがけ/帰りがけの順序を出力",
            "def dfs(s):",
            "    if s:",
            "        order[0].append(s.val) # 行きがけ",
            "        dfs(s.prev)",
            " ",
            "        order[1].append(s.val) # 通りがけ",
            "",
            "        dfs(s.next)",
            "        order[2].append(s.val) # 通りがけ",
            "",
            "N =int(input())",
            "S = input()",
            "",
            "nodes = [Node(i) for i in range(N+1)]",
            "for i in range(len(S)):",
            "    if S[i] == \"R\":",
            "        nodes[i].next = nodes[i+1]",
            "    else:",
            "        nodes[i].prev = nodes[i+1]",
            "",
            "order = [[] for _ in range(3)]",
            "dfs(nodes[0])",
            "print(order)",
        ],
        "description": "Nodeで構築した二分木に対して行きがけ/通りがけ/帰りがけの順序を出力"
    },
    "dfs_stairs": {
        "scope": "python",
        "prefix": "dfs_stairs",
        "body": [
            "# Pythonで提出!!",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "def dfs(n):",
            "    if n == N:",
            "        return 1",
            "    if seen[n]:",
            "        return seen[n]",
            "",
            "    if n+L <= N:",
            "        seen[n] = (seen[n]+dfs(n+L)+dfs(n+1))%(10**9+7)",
            "    elif n+1 <= N:",
            "        seen[n] = (seen[n]+dfs(n+1))%(10**9+7)",
            "",
            "    return seen[n]",
            "",
            "N,L = map(int,input().split())",
            "seen = [0]*(N+1)",
            "print(dfs(0))",
        ],
        "description": "階段の上り方(1段orL段)の数え上げ"
    },
    "bfs_maze": {
        "scope": "python",
        "prefix": "bfs_maze",
        "body": [
            "from collections import deque",
            "",
            "move = ([1, 0], [-1, 0], [0, 1], [0, -1])",
            "#move = ([-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]) #縦横斜め移動",
            "#歩数カウント不要ならvisited = set()として、都度visited.add(nx+ny*C)して管理する方法も可",
            "def bfs(sy,sx,gy,gx):",
            "    queue = deque([[sy,sx]])",
            "    visited = [[-1]*W for _ in range(H)]",
            "    visited[sy][sx] = 0",
            "    while queue:",
            "        y,x = queue.popleft()",
            "        if [y,x] == [gy,gx]:",
            "            return visited[y][x]",
            "        for dy,dx in move:",
            "            ny,nx = y+dy,x+dx",
            "            if 0<=ny<H and 0<=nx<W and maze[ny][nx] == \".\" and visited[ny][nx] == -1:",
            "                visited[ny][nx] = visited[y][x] + 1",
            "                queue.append([ny, nx])",
            "",
            "H,W = map(int, input().split())",
            "sy,sx = map(int, input().split())",
            "gy,gx = map(int, input().split())",
            "sy,sx,gy,gx = sy-1,sx-1,gy-1,gx-1",
            "",
            "maze = [input() for _ in range(H)]",
            "print(bfs(sy,sx,gy,gx))",
            "",
        ],
        "description": "迷路の探索(縦横移動のみ、周囲は全て壁、必ずGにたどり着ける前提)"
    },
    "bfs_graph": {
        "scope": "python",
        "prefix": "bfs_graph",
        "body": [
            "from collections import deque",
            "",
            "def bfs(dist):",
            "    queue = deque()",
            "    queue.append(0)",
            "    while queue:",
            "        s = queue.popleft()",
            "        for to in graph[s]:",
            "            if dist[to] != -1:",
            "                continue",
            "            dist[to] = dist[s] + 1",
            "            queue.append(to)",
            "",
            "N,M = map(int, input().split())",
            "",
            "graph = [[] for _ in range(N)]",
            "for i in range(M):",
            "    a,b = map(int, input().split())",
            "    a,b = a-1,b-1",
            "    graph[a].append(b)",
            "    graph[b].append(a)",
            "",
            "dist = [-1]*N",
            "dist[0] = 0",
            "bfs(dist)",
            "",
        ],
        "description": "グラフの幅優先探索 O(N+M)"
    },
    "bfs_multiStart": {
        "scope": "python",
        "prefix": "bfs_multiStart",
        "body": [
            "from collections import deque",
            "",
            "move = ([1, 0], [-1, 0], [0, 1], [0, -1])",
            "def bfs_MultiStart(s):",
            "    global cnt_black",
            "    queue = deque(s)",
            "",
            "    ans = 0",
            "    while queue:",
            "        if cnt_black == H*W:",
            "            return ans",
            "        ans += 1",
            "        for _ in range(len(queue)):",
            "            y,x = queue.popleft()",
            "            for dy,dx in move:",
            "                ny,nx = y+dy,x+dx",
            "                if 0<=ny<H and 0<=nx<W and A[ny][nx] == \".\":",
            "                    A[ny][nx] = \"#\"",
            "                    cnt_black += 1",
            "                    queue.append((ny, nx))",
        ],
        "description": "多始点BFS"
    },
    "bfs_01": {
        "scope": "python",
        "prefix": "bfs_01",
        "body": [
            "from collections import deque",
            "",
            "def bfs_01(s):",
            "    que = deque([s])",
            "    while que:",
            "        s = que.popleft()",
            "        for to, w in edges[s]:",
            "            d = dist[i] + w",
            "            if d < dist[to]:",
            "                dist[to] = d",
            "                if w == 1:",
            "                    que.append(to)",
            "                else:",
            "                    que.appendleft(to)",
            "",
            "# 頂点数N、始点の頂点番号s",
            "N, s = map(int, input().split())",
            "# 隣接リスト。",
            "# edges[i]の要素に(j, c)が含まれる時、iからjにコストcの辺が存在",
            "edges = [[] for i in range(N)]",
            "",
            "dist = [10**9]*N",
            "dist[s] = 0",
            "bfs_01(s)",
        ],
        "description": "01BFS"
    },
    "topological_sort": {
        "scope": "python",
        "prefix": "topological_sort",
        "body": [
            "from collections import deque",
            "def topological_sort(n, graph):",
            "    # 各頂点への入次数を求める",
            "    indeg = [0] * n",
            "    for i in range(n):",
            "        for to in graph[i]:",
            "            indeg[to] += 1",
            "",
            "    # 入次数が0の頂点はトポソ後のグラフの始点としてよい",
            "    que = deque([i for i in range(n) if indeg[i] == 0])",
            "    ret = []",
            "    cnt = 0 # サイクル判定用",
            "    while que:",
            "        s = que.popleft()",
            "        ret.append(s)",
            "        for to in graph[s]:",
            "            indeg[to] -= 1",
            "            if indeg[to] == 0:",
            "                que.append(to)",
            "        cnt += 1",
            "    ",
            "    # サイクルが存在する場合は-1",
            "    if cnt != n:",
            "        return [-1]",
            " ",
            "    return ret",
        ],
        "description": "トポロジカルソート"
    },
    "topological_sort_lexicographical": {
        "scope": "python",
        "prefix": "topological_sort_lexicographical",
        "body": [
            "from heapq import heapify, heappush, heappop, heappushpop, heapreplace, nlargest, nsmallest  # heapqライブラリのimport",
            "def topological_sort(n, graph):",
            "    # 各頂点への入次数を求める",
            "    indeg = [0] * n",
            "    for i in range(n):",
            "        for to in graph[i]:",
            "            indeg[to] += 1",
            "",
            "    # 入次数が0の頂点はトポソ後のグラフの始点としてよい",
            "    que = [i for i in range(n) if indeg[i] == 0]",
            "    heapify(que)",
            "    ret = []",
            "    cnt = 0 # サイクル判定用",
            "    while que:",
            "        s = heappop(que)",
            "        ret.append(s+1)",
            "        for to in graph[s]:",
            "            indeg[to] -= 1",
            "            if indeg[to] == 0:",
            "                heappush(que,to)",
            "        cnt += 1",
            "",
            "    # サイクルが存在する場合は-1",
            "    if cnt != n:",
            "        return [-1]",
            " ",
            "    return ret",
            "",
        ],
        "description": "トポロジカルソート(辞書順最小)"
    },
    "FloydsCycleDetection": {
        "scope": "python",
        "prefix": "FloydsCycleDetection",
        "body": [
            "# フロイドの循環検出",
            "class Node:",
            "    def __init__(self, val):",
            "        self.val = val",
            "        self.next = None",
            "        self.prev = None",
            "",
            "# サイクル(閉路)があるか判定",
            "def hasCycle(head):",
            "    fast = slow = head",
            "    while fast and fast.next:",
            "        fast = fast.next.next",
            "        slow = slow.next",
            "        if fast == slow:",
            "            return True",
            "    return False",
            "",
            "# サイクル(閉路)の開始地点を探索",
            "def findCycleStart(head):",
            "    fast = slow = head",
            "    while fast and fast.next:",
            "        fast = fast.next.next",
            "        slow = slow.next",
            "        if fast == slow:",
            "            fast = head",
            "            while fast != slow:",
            "                fast = fast.next",
            "                slow = slow.next",
            "            return fast.val",
            "    return None",
            "",
            "# サイクルのループ長を探索",
            "def findCycleLen(head):",
            "    fast = slow = head",
            "    count = 0",
            "    while fast and fast.next:",
            "        count += 1",
            "        fast = fast.next.next",
            "        slow = slow.next",
            "        if fast == slow:",
            "            return count",
            "    return False",
            "",
            "N,K = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "",
            "nodes = [Node(i) for i in range(N)]",
            "for i in range(N):",
            "    nodes[i].next = nodes[(i+A[i])%N]",
            "",
            "# サイクル開始位置と1サイクルの長さを求める",
            "cycleStart = findCycleStart(nodes[0])",
            "cycleLen = findCycleLen(nodes[cycleStart])",
            "",
            "# 1サイクル分の合計",
            "cycleTotal = A[cycleStart]",
            "idx = nodes[cycleStart].next.val",
            "while idx != cycleStart:",
            "    cycleTotal += A[idx]",
            "    idx = nodes[idx].next.val",
            "",
            "ans = 0",
            "# サイクル開始地点までの合計",
            "idx = 0",
            "while idx != cycleStart:",
            "    ans += A[idx]",
            "    idx = nodes[idx].next.val",
            "    K -= 1",
            "    if K == 0:",
            "        print(ans)",
            "        exit()",
            "",
            "# サイクル内ループの合計",
            "ans += cycleTotal * (K // cycleLen)",
            "K %= cycleLen",
            "",
            "# サイクル内ループの余り分の合計",
            "idx = cycleStart",
            "while K > 0:",
            "    ans += A[idx]",
            "    idx = nodes[idx].next.val",
            "    K -= 1",
            "print(ans)",
        ],
        "description": "フロイドの循環検出"
    },
    "CycleSum": {
        "scope": "python",
        "prefix": "CycleSum",
        "body": [
            "N,X,M = map(int,input().split())",
            "",
            "li = [X]",
            "loop_start = 0",
            "check = set([X])",
            "for i in range(N):",
            "    nxt = pow(li[-1],2,M)",
            "    if nxt in check:",
            "        loop_start = li.index(nxt)",
            "        break",
            "    li.append(nxt)",
            "    check.add(nxt)",
            "",
            "loop_len = len(li)-loop_start",
            "r = (N-loop_start)//loop_len",
            "d = (N-loop_start)%loop_len",
            "ini_sum = sum(li[:loop_start])",
            "loop_sum = sum(li[loop_start:])*r",
            "mod_sum = sum(li[loop_start:loop_start+d])",
            "print(ini_sum + loop_sum + mod_sum)",
        ],
        "description": "サイクルを持つリストの和を求める"
    },
    "cumsum": {
        "scope": "python",
        "prefix": "cumsum",
        "body": [
            "import itertools",
            "import operator",
            "cumsum = [0] + list(itertools.accumulate($1, func=operator.add))",
        ],
        "description": "累積和"
    },
    "cumsum_2d": {
        "scope": "python",
        "prefix": "cumsum_2d",
        "body": [
            "H,W = map(int,input().split())",
            "A = [list(map(int,input().split())) for _ in range(H)]",
            "y2,x2,y1,x1 = map(int,input().split())",
            "",
            "cumsum = [[0]*(W+1) for _ in range(H+1)]",
            "for y in range(H):",
            "    for x in range(W):",
            "        cumsum[y+1][x+1] = cumsum[y][x+1] + cumsum[y+1][x] - cumsum[y][x] + A[y][x]",
            "",
            "print(*cumsum,sep=\"\\n\")",
            "print(cumsum[y2][x2] - cumsum[y2][x1-1] - cumsum[y1-1][x2] + cumsum[y1-1][x1-1])",
        ],
        "description": "二次元累積和"
    },
    "imos": {
        "scope": "python",
        "prefix": "imos",
        "body": [
            "enter = [3, 4, 5]",
            "exit = [7, 6, 8]",
            "N = 3",
            "last_exit = max(exit)",
            "table = [0] * (last_exit + 1)",
            "",
            "# 入退店のカウント",
            "for i in range(N):",
            "  table[enter[i]] += 1",
            "  table[exit[i]] -= 1",
            "",
            "# シミュレート(累積和)",
            "for i in range(1, last_exit):",
            "  table[i] += table[i - 1]",
            "",
            "print(table)",
        ],
        "description": "いもす法"
    },
    "imos_2d": {
        "scope": "python",
        "prefix": "imos_2d",
        "body": [
            "N = int(input())",
            "H=W=1001",
            "A = [[0]*W for _ in range(H)]",
            "for _ in range(N):",
            "    lx,ly,rx,ry = map(int,input().split())",
            "    A[ly][lx] += 1",
            "    A[ry][rx] += 1",
            "    A[ry][lx] -= 1",
            "    A[ly][rx] -= 1",
            "",
            "for y in range(H):",
            "    for x in range(1,W):",
            "        A[y][x] += A[y][x-1]",
            "",
            "for y in range(1,H):",
            "    for x in range(W):",
            "        A[y][x] += A[y-1][x]",
            "",
            "ans = [0]*N",
            "for y in range(H):",
            "    for x in range(W):",
            "        if 0 < A[y][x] <= N:",
            "            ans[A[y][x]-1] += 1",
            "for a in ans:",
            "    print(a)",
        ],
        "description": "二次元いもす法"
    },
    "syakutori": {
        "scope": "python",
        "prefix": "syakutori",
        "body": [
            "from collections import deque",
            "q=deque()",
            "for c in a:",
            "    q.append(c)  ## dequeの右端に要素を一つ追加する。",
            "    (追加した要素に応じて何らかの処理を行う)",
            "",
            "    while not (満たすべき条件):",
            "        rm=q.popleft() ## 条件を満たさないのでdequeの左端から要素を取り除く",
            "        (取り除いた要素に応じて何らかの処理を行う)",
            "",
            "    (何らかの処理を行う。whileがbreakしたので、dequeに入っている連続部分列は条件を満たしている。特に右端の要素から左に延ばせる最大の長さになっている。)",
        ],
        "description": "しゃくとり法"
    },
    "BIT": {
        "scope": "python",
        "prefix": "BIT",
        "body": [
            "# BIT(Fenwick Tree) ※一点加算、区間和のRSQ相当",
            "class BIT:",
            "    def __init__(self, n):",
            "        self._n = n",
            "        self.data = [0] * n",
            "",
            "    def add(self, p, x):",
            "        assert 0 <= p < self._n",
            "        p += 1",
            "        while p <= self._n:",
            "            self.data[p - 1] += x",
            "            p += p & -p",
            "",
            "    def sum(self, l, r):",
            "        assert 0 <= l <= r <= self._n",
            "        return self._sum(r) - self._sum(l)",
            "",
            "    def _sum(self, r):",
            "        s = 0",
            "        while r > 0:",
            "            s += self.data[r - 1]",
            "            r -= r & -r",
            "        return s",
            "",
            "'''",
            "bit = BIT(5) # 要素数5個の配列を0で初期化",
            "bit.add(1,3) # bit[1]に3を加算",
            "bit.add(2,5) # bit[2]に5を加算",
            "print(bit.sum(1,3)) # インデックス1から2(半閉半開区間)の要素の合計(=8)を取得",
            "print(bit.data) # [0,3,5,8,0]",
            "'''",
        ],
        "description": "Binary Indexed Tree(Fenwick Tree)　※一点加算、区間和のRSQ相当"
    },
    "SegTree_Abstract": {
        "scope": "python",
        "prefix": "SegTree_Abstract",
        "body": [
            "# 区間に行う操作(最小値:min、最大値:max、区間和:x+y、区間積:x*y、最大公約数:gcd)",
            "def segfunc(x, y):",
            "    return min(x, y)",
            "",
            "# 単位元(最小値:inf、最大値:-inf、区間和:0、区間積:1、最大公約数:0)",
            "# 最小値/最大値はfloat('inf')を避けた方が高速化できる",
            "ide_ele = 10**18",
            "",
            "class SegTree:",
            "    \"\"\"",
            "    init(init_val, segfunc,ide_ele): 配列init_valで初期化 O(N)",
            "    update(k, x): k番目の値をxに更新 O(N)",
            "    query(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)",
            "    \"\"\"",
            "    def __init__(self, init_val, segfunc, ide_ele):",
            "        \"\"\"",
            "        n: 要素数",
            "        num: n以上の最小の2のべき乗",
            "        tree: セグメント木(1-index)",
            "        \"\"\"",
            "        n = len(init_val)",
            "        self.segfunc = segfunc",
            "        self.ide_ele = ide_ele",
            "        self.num = 1 << (n - 1).bit_length()",
            "        self.tree = [ide_ele] * 2 * self.num",
            "        # 配列の値を葉にセット",
            "        for i in range(n):",
            "            self.tree[self.num + i] = init_val[i]",
            "        # 構築していく",
            "        for i in range(self.num - 1, 0, -1):",
            "            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
            "",
            "    def update(self, k, x):",
            "        \"\"\"",
            "        k番目の値をxに更新",
            "        k: index(0-index)",
            "        x: update value",
            "        \"\"\"",
            "        k += self.num",
            "        self.tree[k] = x",
            "        while k > 1:",
            "            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
            "            k >>= 1",
            "",
            "    def query(self, l, r):",
            "        \"\"\"",
            "        [l, r)のsegfuncしたものを得る",
            "        l: index(0-index)",
            "        r: index(0-index)",
            "        \"\"\"",
            "        res = self.ide_ele",
            "",
            "        l += self.num",
            "        r += self.num",
            "        while l < r:",
            "            if l & 1:",
            "                res = self.segfunc(res, self.tree[l])",
            "                l += 1",
            "            if r & 1:",
            "                res = self.segfunc(res, self.tree[r - 1])",
            "            l >>= 1",
            "            r >>= 1",
            "        return res",
            "",
            "seg = SegTree(, segfunc, ide_ele)",
            "'''",
            "print(seg.query(0, 8))",
            "seg.update(5, 0)",
            "print(seg.query(0, 8))",
            "'''",
        ],
        "description": "抽象化セグメント木"
    },
    "RMQ_RUQ": {
        "scope": "python",
        "prefix": "RMQ_RUQ",
        "body": [
            "# N: 処理する区間の長さ",
            "",
            "INF = 2**31-1",
            "",
            "LV = (N-1).bit_length()",
            "N0 = 2**LV",
            "data = [INF]*(2*N0)",
            "lazy = [None]*(2*N0)",
            "",
            "# 伝搬対象の区間を求める",
            "def gindex(l, r):",
            "    L = (l + N0) >> 1; R = (r + N0) >> 1",
            "    lc = 0 if l & 1 else (L & -L).bit_length()",
            "    rc = 0 if r & 1 else (R & -R).bit_length()",
            "    for i in range(LV):",
            "        if rc <= i:",
            "            yield R",
            "        if L < R and lc <= i:",
            "            yield L",
            "        L >>= 1; R >>= 1",
            "",
            "# 遅延伝搬処理",
            "def propagates(*ids):",
            "    for i in reversed(ids):",
            "        v = lazy[i-1]",
            "        if v is None:",
            "            continue",
            "        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v",
            "        lazy[i-1] = None",
            "",
            "# 区間[l, r)をxで更新",
            "def update(l, r, x):",
            "    *ids, = gindex(l, r)",
            "    propagates(*ids)",
            "",
            "    L = N0 + l; R = N0 + r",
            "    while L < R:",
            "        if R & 1:",
            "            R -= 1",
            "            lazy[R-1] = data[R-1] = x",
            "        if L & 1:",
            "            lazy[L-1] = data[L-1] = x",
            "            L += 1",
            "        L >>= 1; R >>= 1",
            "    for i in ids:",
            "        data[i-1] = min(data[2*i-1], data[2*i])",
            "",
            "# 区間[l, r)内の最小値を求める",
            "def query(l, r):",
            "    propagates(*gindex(l, r))",
            "    L = N0 + l; R = N0 + r",
            "",
            "    s = INF",
            "    while L < R:",
            "        if R & 1:",
            "            R -= 1",
            "            s = min(s, data[R-1])",
            "        if L & 1:",
            "            s = min(s, data[L-1])",
            "            L += 1",
            "        L >>= 1; R >>= 1",
            "    return s",
        ],
        "description": "RMQ(区間最小)、RUQ(区間更新)"
    },
    "01knapsack": {
        "scope": "python",
        "prefix": "knapsack",
        "body": [
            "N,W = map(int,input().split())",
            "goods = [list(map(int,input().split())) for _ in range(N)]",
            "",
            "dp = [[0]*(W+1) for _ in range(N+1)]",
            "",
            "for i in range(N):",
            "    for j in range(W+1):",
            "        if j-goods[i][1] >= 0:",
            "            dp[i+1][j] = max(dp[i][j], dp[i][j-goods[i][1]] + goods[i][0]) # 0-1ナップザック",
            "            # dp[i+1][j] = max(dp[i][j], dp[i][j-goods[i][1]] + goods[i][0], dp[i+1][j-goods[i][1]] + goods[i][0]) # 重複あり",
            "        else:",
            "            dp[i+1][j] = dp[i][j]",
            "",
            "print(dp[N][W])",
            "",
        ],
        "description": "ナップザック問題"
    },
    "treeDP": {
        "scope": "python",
        "prefix": "treeDP",
        "body": [
            "# Pythonで提出!!",
            "import sys",
            "sys.setrecursionlimit(10**7)",
            "",
            "def dfs(s,pre):",
            "    for to in graph[s]:",
            "        if to != pre: # to == preが葉(末端ノード)を表す",
            "            dfs(to,s)",
            "            dp[s] = max(dp[s], dp[to]+1)",
            "",
            "N,M = map(int,input().split())",
            "M -= 1",
            "graph = [[] for _ in range(N)]",
            "for _ in range(N-1):",
            "    a,b =map(int,input().split())",
            "    a,b = a-1,b-1",
            "    graph[a].append(b)",
            "    graph[b].append(a)",
            "",
            "dp = [0]*N",
            "dfs(M,-1)",
            "print(*dp)",
        ],
        "description": "木DP(根から最も遠い頂点までの深さを求める)"
    },
    "probability_mod": {
        "scope": "python",
        "prefix": "probability_mod(dp)",
        "body": [
            "# 確率MOD典型",
            "# ModIntを用いて確率をDP/メモ化再帰で計算する",
            "# iP = 1 / ModInt(P)のように予め分母をModIntで計算しておき、",
            "# dp[i][j][0] *= iPのように逆元として乗算する(dpの値は分子が取りうる通り数の数え上げ)",
            "# ※ターン制2人ゲームの場合は、dp[i][j][f]のfでAのターン→Bのターン(またその逆)の遷移を表現してゴールから計算",
            "# 参考提出",
            "# E - Dice Product 3 (https://atcoder.jp/contests/abc300/submissions/41068136)",
            "# E - Unfair Sugoroku (https://atcoder.jp/contests/abc298/submissions/41068068)",
        ],
        "description": "確率MODを使う問題が出た時の考え方"
    },
    "Zobrist Hash": {
        "scope": "python",
        "prefix": "Zobrist Hash",
        "body": [
            "# Zobrist Hash(例題：ABC250 - E - Prefix Equality)",
            "import random",
            "",
            "N =int(input())",
            "A =list(map(int,input().split()))",
            "B =list(map(int,input().split()))",
            "Q =int(input())",
            "",
            "# リストの各要素をユニークな乱数に変換",
            "rand = {}",
            "for a,b in zip(A,B):",
            "    if a not in rand:",
            "        rand[a] = random.randrange(1 << 64)",
            "",
            "    if b not in rand:",
            "        rand[b] = random.randrange(1 << 64)",
            "",
            "# リストの先頭から順に集合の状態をハッシュ化(累積XOR)",
            "zhA,zhB = [0],[0]",
            "setA,setB = set(),set()",
            "for a,b in zip(A,B):",
            "    if a in setA:",
            "        zhA.append(zhA[-1])",
            "    else:",
            "        zhA.append(zhA[-1] ^ rand[a])",
            "        setA.add(a)",
            "",
            "    if b in setB:",
            "        zhB.append(zhB[-1])",
            "    else:",
            "        zhB.append(zhB[-1] ^ rand[b])",
            "        setB.add(b)",
            "",
            "# ハッシュ値を比較し、同じ集合か判定",
            "for _ in range(Q):",
            "    x,y = map(int, input().split())",
            "    if zhA[x] == zhB[y]:",
            "        print(\"Yes\")",
            "    else:",
            "        print(\"No\")",
        ],
        "description": "Zobrist Hash(状態をハッシュ化)"
    },
}